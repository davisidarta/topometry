

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>NumPy C-API &mdash; TopOMetry  documentation</title>
  

  
  <link rel="stylesheet" href="../../../../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../../../../_static/pygments.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../../../../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../../../../" src="../../../../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../../../../_static/jquery.js"></script>
        <script src="../../../../../../../../_static/underscore.js"></script>
        <script src="../../../../../../../../_static/doctools.js"></script>
        <script src="../../../../../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../../../../../_static/js/theme.js"></script>

    
    <link rel="author" title="About these documents" href="../../../../../../../../about.html" />
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../../../../index.html" class="icon icon-home" alt="Documentation Home"> TopOMetry
          

          
            
            <img src="../../../../../../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../quickstart.html">Quick-start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../topograph.html">TopOGraph API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">TopOMetry</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>NumPy C-API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../../../../../_sources/env/lib/python3.8/site-packages/numpy/core/include/numpy/multiarray_api.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="numpy-c-api">
<h1>NumPy C-API<a class="headerlink" href="#numpy-c-api" title="Permalink to this headline">¶</a></h1>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="nb">int</span>
<span class="n">PyArray_GetNDArrayCVersion</span><span class="p">(</span><span class="n">void</span> <span class="p">)</span>
</pre></div>
</div>
<p>Included at the very first so not auto-grabbed and thus not labeled.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_SetNumericOps</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="nb">dict</span><span class="p">)</span>
</pre></div>
</div>
<p>Set internal structure with number functions that all arrays will use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_GetNumericOps</span><span class="p">(</span><span class="n">void</span> <span class="p">)</span>
</pre></div>
</div>
<p>Get dictionary showing number functions that all arrays will use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_INCREF</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
</pre></div>
</div>
<p>For object arrays, increment all internal references.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_XDECREF</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
</pre></div>
</div>
<p>Decrement all internal references for object arrays.
(or arrays with object fields)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_SetStringFunction</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="nb">int</span> <span class="nb">repr</span><span class="p">)</span>
</pre></div>
</div>
<p>Set the array print function to be a Python function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span> <span class="o">*</span>
<span class="n">PyArray_DescrFromType</span><span class="p">(</span><span class="nb">int</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the PyArray_Descr structure for a type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_TypeObjectFromType</span><span class="p">(</span><span class="nb">int</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>
</div>
<p>Get a typeobject from a type-number – can return NULL.</p>
<p>New reference</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="o">*</span>
<span class="n">PyArray_Zero</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
<p>Get pointer to zero of correct type for array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="o">*</span>
<span class="n">PyArray_One</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
<p>Get pointer to one of correct type for array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_CastToType</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">int</span>
                   <span class="n">is_f_order</span><span class="p">)</span>
</pre></div>
</div>
<p>For backward compatibility</p>
<p>Cast an array using typecode structure.
steals reference to dtype — cannot be NULL</p>
<p>This function always makes a copy of arr, even if the dtype
doesn’t change.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CastTo</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
</pre></div>
</div>
<p>Cast to an already created array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CastAnyTo</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
</pre></div>
</div>
<p>Cast to an already created array.  Arrays don’t have to be “broadcastable”
Only requirement is they have the same number of elements.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CanCastSafely</span><span class="p">(</span><span class="nb">int</span> <span class="n">fromtype</span><span class="p">,</span> <span class="nb">int</span> <span class="n">totype</span><span class="p">)</span>
</pre></div>
</div>
<p>Check the type coercion rules.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">PyArray_CanCastTo</span><span class="p">(</span><span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
</pre></div>
</div>
<p>leaves reference count alone — cannot be NULL</p>
<p>PyArray_CanCastTypeTo is equivalent to this, but adds a ‘casting’
parameter.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_ObjectType</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="nb">int</span> <span class="n">minimum_type</span><span class="p">)</span>
</pre></div>
</div>
<p>Return the typecode of the array a Python object would be converted to</p>
<p>Returns the type number the result should have, or NPY_NOTYPE on error.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span> <span class="o">*</span>
<span class="n">PyArray_DescrFromObject</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">mintype</span><span class="p">)</span>
</pre></div>
</div>
<p>new reference – accepts NULL for mintype</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArrayObject</span> <span class="o">**</span>
<span class="n">PyArray_ConvertToCommonType</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">retn</span><span class="p">)</span>
</pre></div>
</div>
<p>This function is only used in one place within NumPy and should
generally be avoided. It is provided mainly for backward compatibility.</p>
<p>The user of the function has to free the returned array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span> <span class="o">*</span>
<span class="n">PyArray_DescrFromScalar</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
</pre></div>
</div>
<p>Return descr object from array scalar.</p>
<p>New reference</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span> <span class="o">*</span>
<span class="n">PyArray_DescrFromTypeObject</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="nb">type</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span>
<span class="n">PyArray_Size</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the size of an array (in number of items)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Scalar</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
</pre></div>
</div>
<p>Get scalar-equivalent to a region of memory described by a descriptor.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromScalar</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">scalar</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">outcode</span><span class="p">)</span>
</pre></div>
</div>
<p>Get 0-dim array from scalar</p>
<p>0-dim array from array-scalar object
always contains a copy of the data
unless outcode is NULL, it is of void type and the referrer does
not own it either.</p>
<p>steals reference to outcode</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_ScalarAsCtype</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">scalar</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">ctypeptr</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert to c-type</p>
<p>no error checking is performed – ctypeptr must be same type as scalar
in case of flexible type, the data is not copied
into ctypeptr which is expected to be a pointer to pointer</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CastScalarToCtype</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">scalar</span><span class="p">,</span> <span class="n">void</span>
                          <span class="o">*</span><span class="n">ctypeptr</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">outcode</span><span class="p">)</span>
</pre></div>
</div>
<p>Cast Scalar to c-type</p>
<p>The output buffer must be large-enough to receive the value
Even for flexible types which is different from ScalarAsCtype
where only a reference for flexible types is returned</p>
<p>This may not work right on narrow builds for NumPy unicode scalars.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CastScalarDirect</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">scalar</span><span class="p">,</span> <span class="n">PyArray_Descr</span>
                         <span class="o">*</span><span class="n">indescr</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">ctypeptr</span><span class="p">,</span> <span class="nb">int</span> <span class="n">outtype</span><span class="p">)</span>
</pre></div>
</div>
<p>Cast Scalar to c-type</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_ScalarFromObject</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="nb">object</span><span class="p">)</span>
</pre></div>
</div>
<p>Get an Array Scalar From a Python Object</p>
<p>Returns NULL if unsuccessful but error is only set if another error occurred.
Currently only Numeric-like object supported.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_VectorUnaryFunc</span> <span class="o">*</span>
<span class="n">PyArray_GetCastFunc</span><span class="p">(</span><span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="nb">int</span> <span class="n">type_num</span><span class="p">)</span>
</pre></div>
</div>
<p>Get a cast function to cast from the input descriptor to the
output type_number (must be a registered data-type).
Returns NULL if un-successful.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromDims</span><span class="p">(</span><span class="nb">int</span> <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span> <span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">,</span> <span class="nb">int</span>
                 <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Deprecated, use PyArray_SimpleNew instead.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromDimsAndDataAndDescr</span><span class="p">(</span><span class="nb">int</span> <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span> <span class="p">,</span> <span class="nb">int</span>
                                <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">,</span> <span class="n">PyArray_Descr</span>
                                <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Deprecated, use PyArray_NewFromDescr instead.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromAny</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">newtype</span><span class="p">,</span> <span class="nb">int</span>
                <span class="n">min_depth</span><span class="p">,</span> <span class="nb">int</span> <span class="n">max_depth</span><span class="p">,</span> <span class="nb">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">PyObject</span>
                <span class="o">*</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
<p>Does not check for NPY_ARRAY_ENSURECOPY and NPY_ARRAY_NOTSWAPPED in flags
Steals a reference to newtype — which can be NULL</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_EnsureArray</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
<p>This is a quick wrapper around
PyArray_FromAny(op, NULL, 0, 0, NPY_ARRAY_ENSUREARRAY, NULL)
that special cases Arrays and PyArray_Scalars up front
It <em>steals a reference</em> to the object
It also guarantees that the result is PyArray_Type
Because it decrefs op if any conversion needs to take place
so it can be used like PyArray_EnsureArray(some_function(…))</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_EnsureAnyArray</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromFile</span><span class="p">(</span><span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">dtype</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">num</span><span class="p">,</span> <span class="n">char</span>
                 <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
</pre></div>
</div>
<p>Given a <code class="docutils literal notranslate"><span class="pre">FILE</span> <span class="pre">*</span></code> pointer <code class="docutils literal notranslate"><span class="pre">fp</span></code>, and a <code class="docutils literal notranslate"><span class="pre">PyArray_Descr</span></code>, return an
array corresponding to the data encoded in that file.</p>
<p>The reference to <cite>dtype</cite> is stolen (it is possible that the passed in
dtype is not held on to).</p>
<p>The number of elements to read is given as <code class="docutils literal notranslate"><span class="pre">num</span></code>; if it is &lt; 0, then
then as many as possible are read.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sep</span></code> is NULL or empty, then binary data is assumed, else
text data, with <code class="docutils literal notranslate"><span class="pre">sep</span></code> as the separator between elements. Whitespace in
the separator matches any length of whitespace in the text, and a match
for whitespace around the separator is added.</p>
<p>For memory-mapped files, use the buffer interface. No more data than
necessary is read by this routine.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromString</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">slen</span><span class="p">,</span> <span class="n">PyArray_Descr</span>
                   <span class="o">*</span><span class="n">dtype</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">num</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">sep</span><span class="p">)</span>
</pre></div>
</div>
<p>Given a pointer to a string <code class="docutils literal notranslate"><span class="pre">data</span></code>, a string length <code class="docutils literal notranslate"><span class="pre">slen</span></code>, and
a <code class="docutils literal notranslate"><span class="pre">PyArray_Descr</span></code>, return an array corresponding to the data
encoded in that string.</p>
<p>If the dtype is NULL, the default array type is used (double).
If non-null, the reference is stolen.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">slen</span></code> is &lt; 0, then the end of string is used for text data.
It is an error for <code class="docutils literal notranslate"><span class="pre">slen</span></code> to be &lt; 0 for binary data (since embedded NULLs
would be the norm).</p>
<p>The number of elements to read is given as <code class="docutils literal notranslate"><span class="pre">num</span></code>; if it is &lt; 0, then
then as many as possible are read.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sep</span></code> is NULL or empty, then binary data is assumed, else
text data, with <code class="docutils literal notranslate"><span class="pre">sep</span></code> as the separator between elements. Whitespace in
the separator matches any length of whitespace in the text, and a match
for whitespace around the separator is added.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromBuffer</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="nb">type</span><span class="p">,</span> <span class="n">npy_intp</span>
                   <span class="n">count</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromIter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">dtype</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>steals a reference to dtype (which cannot be NULL)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Return</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
</pre></div>
</div>
<p>Return either an array or the appropriate Python object if the array
is 0d and matches a Python type.
steals reference to mp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_GetField</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">typed</span><span class="p">,</span> <span class="nb">int</span>
                 <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>Get a subset of bytes from each element of the array
steals reference to typed, must not be NULL</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_SetField</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">int</span>
                 <span class="n">offset</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>Set a subset of bytes from each element of the array
steals reference to dtype, must not be NULL</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Byteswap</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">npy_bool</span> <span class="n">inplace</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Resize</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyArray_Dims</span> <span class="o">*</span><span class="n">newshape</span><span class="p">,</span> <span class="nb">int</span>
               <span class="n">refcheck</span><span class="p">,</span> <span class="n">NPY_ORDER</span> <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Resize (reallocate data).  Only works if nothing else is referencing this
array and it is contiguous.  If refcheck is 0, then the reference count is
not checked and assumed to be 1.  You still must own this data and have no
weak-references and no base object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_MoveInto</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
</pre></div>
</div>
<p>Move the memory of one array into another, allowing for overlapping data.</p>
<p>Returns 0 on success, negative on failure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CopyInto</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
</pre></div>
</div>
<p>Copy an Array into another array.
Broadcast to the destination shape if necessary.</p>
<p>Returns 0 on success, -1 on failure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CopyAnyInto</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
</pre></div>
</div>
<p>Copy an Array into another array – memory must not overlap
Does not require src and dest to have “broadcastable” shapes
(only the same number of elements).</p>
<p>TODO: For NumPy 2.0, this could accept an order parameter which
only allows NPY_CORDER and NPY_FORDER.  Could also rename
this to CopyAsFlat to make the name more intuitive.</p>
<p>Returns 0 on success, -1 on error.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CopyObject</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">src_object</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_NewCopy</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">NPY_ORDER</span> <span class="n">order</span><span class="p">)</span>
</pre></div>
</div>
<p>Copy an array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_ToList</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>To List</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_ToString</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">NPY_ORDER</span> <span class="n">order</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_ToFile</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">sep</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">)</span>
</pre></div>
</div>
<p>To File</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_Dump</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="nb">int</span> <span class="n">protocol</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Dumps</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="nb">int</span> <span class="n">protocol</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_ValidType</span><span class="p">(</span><span class="nb">int</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>
</div>
<p>Is the typenum valid?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_UpdateFlags</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">ret</span><span class="p">,</span> <span class="nb">int</span> <span class="n">flagmask</span><span class="p">)</span>
</pre></div>
</div>
<p>Update Several Flags at once.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_New</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">subtype</span><span class="p">,</span> <span class="nb">int</span> <span class="n">nd</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">dims</span><span class="p">,</span> <span class="nb">int</span>
            <span class="n">type_num</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">strides</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="nb">int</span>
            <span class="n">itemsize</span><span class="p">,</span> <span class="nb">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>Generic new array creation routine.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_NewFromDescr</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">subtype</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="nb">int</span>
                     <span class="n">nd</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">dims</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span>
                     <span class="o">*</span><span class="n">strides</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="nb">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>Generic new array creation routine.</p>
<p>steals a reference to descr. On failure or when dtype-&gt;subarray is
true, dtype will be decrefed.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span> <span class="o">*</span>
<span class="n">PyArray_DescrNew</span><span class="p">(</span><span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
</pre></div>
</div>
<p>base cannot be NULL</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span> <span class="o">*</span>
<span class="n">PyArray_DescrNewFromType</span><span class="p">(</span><span class="nb">int</span> <span class="n">type_num</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span>
<span class="n">PyArray_GetPriority</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">double</span> <span class="n">default_</span><span class="p">)</span>
</pre></div>
</div>
<p>Get Priority from object</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_IterNew</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>Get Iterator.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="o">*</span>
<span class="n">PyArray_MultiIterNew</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="o">...</span> <span class="p">)</span>
</pre></div>
</div>
<p>Get MultiIterator,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_PyIntAsInt</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span>
<span class="n">PyArray_PyIntAsIntp</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_Broadcast</span><span class="p">(</span><span class="n">PyArrayMultiIterObject</span> <span class="o">*</span><span class="n">mit</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_FillObjectArray</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>Assumes contiguous</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_FillWithScalar</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">PyArray_CheckStrides</span><span class="p">(</span><span class="nb">int</span> <span class="n">elsize</span><span class="p">,</span> <span class="nb">int</span> <span class="n">nd</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">numbytes</span><span class="p">,</span> <span class="n">npy_intp</span>
                     <span class="n">offset</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">dims</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span>
                     <span class="o">*</span><span class="n">newstrides</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span> <span class="o">*</span>
<span class="n">PyArray_DescrNewByteorder</span><span class="p">(</span><span class="n">PyArray_Descr</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">char</span> <span class="n">newendian</span><span class="p">)</span>
</pre></div>
</div>
<p>returns a copy of the PyArray_Descr structure with the byteorder
altered:
no arguments:  The byteorder is swapped (in all subfields as well)
single argument:  The byteorder is forced to the given state
(in all subfields as well)</p>
<p>Valid states:  (‘big’, ‘&gt;’) or (‘little’ or ‘&lt;’)
(‘native’, or ‘=’)</p>
<p>If a descr structure with | is encountered it’s own
byte-order is not changed but any fields are:</p>
<p>Deep bytorder change of a data-type descriptor
Leaves reference count of self unchanged — does not DECREF self <a href="#id1"><span class="problematic" id="id2">**</span></a><a href="#id3"><span class="problematic" id="id4">*</span></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_IterAllButAxis</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">inaxis</span><span class="p">)</span>
</pre></div>
</div>
<p>Get Iterator that iterates over all but one axis (don’t use this with
PyArray_ITER_GOTO1D).  The axis will be over-written if negative
with the axis having the smallest stride.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_CheckFromAny</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="nb">int</span>
                     <span class="n">min_depth</span><span class="p">,</span> <span class="nb">int</span> <span class="n">max_depth</span><span class="p">,</span> <span class="nb">int</span> <span class="n">requires</span><span class="p">,</span> <span class="n">PyObject</span>
                     <span class="o">*</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
<p>steals a reference to descr – accepts NULL</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromArray</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">newtype</span><span class="p">,</span> <span class="nb">int</span>
                  <span class="n">flags</span><span class="p">)</span>
</pre></div>
</div>
<p>steals reference to newtype — acc. NULL</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromInterface</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">origin</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromStructInterface</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="nb">input</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FromArrayAttr</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">typecode</span><span class="p">,</span> <span class="n">PyObject</span>
                      <span class="o">*</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NPY_SCALARKIND</span>
<span class="n">PyArray_ScalarKind</span><span class="p">(</span><span class="nb">int</span> <span class="n">typenum</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">**</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
<p>ScalarKind</p>
<p>Returns the scalar kind of a type number, with an
optional tweak based on the scalar value itself.
If no scalar is provided, it returns INTPOS_SCALAR
for both signed and unsigned integers, otherwise
it checks the sign of any signed integer to choose
INTNEG_SCALAR when appropriate.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CanCoerceScalar</span><span class="p">(</span><span class="nb">int</span> <span class="n">thistype</span><span class="p">,</span> <span class="nb">int</span> <span class="n">neededtype</span><span class="p">,</span> <span class="n">NPY_SCALARKIND</span>
                        <span class="n">scalar</span><span class="p">)</span>
</pre></div>
</div>
<p>Determines whether the data type ‘thistype’, with
scalar kind ‘scalar’, can be coerced into ‘neededtype’.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_NewFlagsObject</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>Get New ArrayFlagsObject</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">PyArray_CanCastScalar</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
</pre></div>
</div>
<p>See if array scalars can be cast.</p>
<p>TODO: For NumPy 2.0, add a NPY_CASTING parameter.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CompareUCS4</span><span class="p">(</span><span class="n">npy_ucs4</span> <span class="n">const</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="n">npy_ucs4</span> <span class="n">const</span> <span class="o">*</span><span class="n">s2</span><span class="p">,</span> <span class="n">size_t</span>
                    <span class="nb">len</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_RemoveSmallest</span><span class="p">(</span><span class="n">PyArrayMultiIterObject</span> <span class="o">*</span><span class="n">multi</span><span class="p">)</span>
</pre></div>
</div>
<p>Adjusts previously broadcasted iterators so that the axis with
the smallest sum of iterator strides is not iterated over.
Returns dimension which is smallest in the range [0,multi-&gt;nd).
A -1 is returned if multi-&gt;nd == 0.</p>
<p>don’t use with PyArray_ITER_GOTO1D because factors are not adjusted</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_ElementStrides</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_Item_INCREF</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">)</span>
</pre></div>
</div>
<p>XINCREF all objects in a single array item. This is complicated for
structured datatypes where the position of objects needs to be extracted.
The function is execute recursively for each nested field or subarrays dtype
such as as <cite>np.dtype([(“field1”, “O”), (“field2”, “f,O”, (3,2))])</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_Item_XDECREF</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">)</span>
</pre></div>
</div>
<p>XDECREF all objects in a single array item. This is complicated for
structured datatypes where the position of objects needs to be extracted.
The function is execute recursively for each nested field or subarrays dtype
such as as <cite>np.dtype([(“field1”, “O”), (“field2”, “f,O”, (3,2))])</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_FieldNames</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">fields</span><span class="p">)</span>
</pre></div>
</div>
<p>Return the tuple of ordered field names from a dictionary.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Transpose</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">PyArray_Dims</span> <span class="o">*</span><span class="n">permute</span><span class="p">)</span>
</pre></div>
</div>
<p>Return Transpose.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_TakeFrom</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">self0</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">indices0</span><span class="p">,</span> <span class="nb">int</span>
                 <span class="n">axis</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">NPY_CLIPMODE</span> <span class="n">clipmode</span><span class="p">)</span>
</pre></div>
</div>
<p>Take</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_PutTo</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyObject</span><span class="o">*</span><span class="n">values0</span><span class="p">,</span> <span class="n">PyObject</span>
              <span class="o">*</span><span class="n">indices0</span><span class="p">,</span> <span class="n">NPY_CLIPMODE</span> <span class="n">clipmode</span><span class="p">)</span>
</pre></div>
</div>
<p>Put values into an array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_PutMask</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyObject</span><span class="o">*</span><span class="n">values0</span><span class="p">,</span> <span class="n">PyObject</span><span class="o">*</span><span class="n">mask0</span><span class="p">)</span>
</pre></div>
</div>
<p>Put values into an array according to a mask.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Repeat</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">aop</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">)</span>
</pre></div>
</div>
<p>Repeat the array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Choose</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyArrayObject</span>
               <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">NPY_CLIPMODE</span> <span class="n">clipmode</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_Sort</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="n">NPY_SORTKIND</span> <span class="n">which</span><span class="p">)</span>
</pre></div>
</div>
<p>Sort an array in-place</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_ArgSort</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="n">NPY_SORTKIND</span> <span class="n">which</span><span class="p">)</span>
</pre></div>
</div>
<p>ArgSort an array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_SearchSorted</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">op2</span><span class="p">,</span> <span class="n">NPY_SEARCHSIDE</span>
                     <span class="n">side</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">perm</span><span class="p">)</span>
</pre></div>
</div>
<p>Search the sorted array op1 for the location of the items in op2. The
result is an array of indexes, one for each element in op2, such that if
the item were to be inserted in op1 just before that index the array
would still be in sorted order.</p>
<div class="section" id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h2>
<p>op1 : PyArrayObject *
Array to be searched, must be 1-D.
op2 : PyObject *
Array of items whose insertion indexes in op1 are wanted
side : {NPY_SEARCHLEFT, NPY_SEARCHRIGHT}
If NPY_SEARCHLEFT, return first valid insertion indexes
If NPY_SEARCHRIGHT, return last valid insertion indexes
perm : PyObject *
Permutation array that sorts op1 (optional)</p>
</div>
<div class="section" id="returns">
<h2>Returns<a class="headerlink" href="#returns" title="Permalink to this headline">¶</a></h2>
<p>ret : PyObject *
New reference to npy_intp array containing indexes where items in op2
could be validly inserted into op1. NULL on error.</p>
</div>
<div class="section" id="notes">
<h2>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<p>Binary search is used to find the indexes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_ArgMax</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>ArgMax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_ArgMin</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>ArgMin</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Reshape</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Reshape</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Newshape</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyArray_Dims</span> <span class="o">*</span><span class="n">newdims</span><span class="p">,</span> <span class="n">NPY_ORDER</span>
                 <span class="n">order</span><span class="p">)</span>
</pre></div>
</div>
<p>New shape for an array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Squeeze</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>return a new view of the array object with all of its unit-length
dimensions squeezed out if needed, otherwise
return the same array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_View</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="nb">type</span><span class="p">,</span> <span class="n">PyTypeObject</span>
             <span class="o">*</span><span class="n">pytype</span><span class="p">)</span>
</pre></div>
</div>
<p>View
steals a reference to type – accepts NULL</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_SwapAxes</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="nb">int</span> <span class="n">a1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">a2</span><span class="p">)</span>
</pre></div>
</div>
<p>SwapAxes</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Max</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Max</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Min</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Min</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Ptp</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Ptp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Mean</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rtype</span><span class="p">,</span> <span class="n">PyArrayObject</span>
             <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Mean</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Trace</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="nb">int</span> <span class="n">offset</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis1</span><span class="p">,</span> <span class="nb">int</span>
              <span class="n">axis2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rtype</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Trace</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Diagonal</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="nb">int</span> <span class="n">offset</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis1</span><span class="p">,</span> <span class="nb">int</span>
                 <span class="n">axis2</span><span class="p">)</span>
</pre></div>
</div>
<p>Diagonal</p>
<p>In NumPy versions prior to 1.7,  this function always returned a copy of
the diagonal array. In 1.7, the code has been updated to compute a view
onto ‘self’, but it still copies this array before returning, as well as
setting the internal WARN_ON_WRITE flag. In a future version, it will
simply return a view onto self.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Clip</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="nb">min</span><span class="p">,</span> <span class="n">PyObject</span>
             <span class="o">*</span><span class="nb">max</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Clip</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Conjugate</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Conjugate</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Nonzero</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Nonzero</p>
<p>TODO: In NumPy 2.0, should make the iteration order a parameter.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Std</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rtype</span><span class="p">,</span> <span class="n">PyArrayObject</span>
            <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">variance</span><span class="p">)</span>
</pre></div>
</div>
<p>Set variance to 1 to by-pass square-root calculation and return variance
Std</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Sum</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rtype</span><span class="p">,</span> <span class="n">PyArrayObject</span>
            <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Sum</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_CumSum</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rtype</span><span class="p">,</span> <span class="n">PyArrayObject</span>
               <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>CumSum</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Prod</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rtype</span><span class="p">,</span> <span class="n">PyArrayObject</span>
             <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Prod</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_CumProd</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="nb">int</span>
                <span class="n">rtype</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>CumProd</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_All</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>All</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Any</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Any</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Compress</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">condition</span><span class="p">,</span> <span class="nb">int</span>
                 <span class="n">axis</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Compress</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Flatten</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">NPY_ORDER</span> <span class="n">order</span><span class="p">)</span>
</pre></div>
</div>
<p>Flatten</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Ravel</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="n">NPY_ORDER</span> <span class="n">order</span><span class="p">)</span>
</pre></div>
</div>
<p>Ravel
Returns a contiguous array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span>
<span class="n">PyArray_MultiplyList</span><span class="p">(</span><span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">l1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Multiply a List</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_MultiplyIntList</span><span class="p">(</span><span class="nb">int</span> <span class="n">const</span> <span class="o">*</span><span class="n">l1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Multiply a List of ints</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="o">*</span>
<span class="n">PyArray_GetPtr</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span><span class="o">*</span><span class="n">ind</span><span class="p">)</span>
</pre></div>
</div>
<p>Produce a pointer into array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CompareLists</span><span class="p">(</span><span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">l1</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">l2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Compare Lists</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_AsCArray</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">**</span><span class="n">op</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="o">*</span><span class="n">dims</span><span class="p">,</span> <span class="nb">int</span>
                 <span class="n">nd</span><span class="p">,</span> <span class="n">PyArray_Descr</span><span class="o">*</span><span class="n">typedescr</span><span class="p">)</span>
</pre></div>
</div>
<p>Simulate a C-array
steals a reference to typedescr – can be NULL</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_As1D</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">**</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">,</span> <span class="nb">int</span>
             <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="p">,</span> <span class="nb">int</span> <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">typecode</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Convert to a 1D C-array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_As2D</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">**</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">,</span> <span class="n">char</span> <span class="o">***</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">,</span> <span class="nb">int</span>
             <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span> <span class="p">,</span> <span class="nb">int</span>
             <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">typecode</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Convert to a 2D C-array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_Free</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
</pre></div>
</div>
<p>Free pointers created if As2D is called</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_Converter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="nb">object</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">**</span><span class="n">address</span><span class="p">)</span>
</pre></div>
</div>
<p>Useful to pass as converter function for O&amp; processing in PyArgs_ParseTuple.</p>
<p>This conversion function can be used with the “O&amp;” argument for
PyArg_ParseTuple.  It will immediately return an object of array type
or will convert to a NPY_ARRAY_CARRAY any other object.</p>
<p>If you use PyArray_Converter, you must DECREF the array when finished
as you get a new reference to it.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_IntpFromSequence</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="o">*</span><span class="n">vals</span><span class="p">,</span> <span class="nb">int</span> <span class="n">maxvals</span><span class="p">)</span>
</pre></div>
</div>
<p>PyArray_IntpFromSequence
Returns the number of integers converted or -1 if an error occurred.
vals must be large enough to hold maxvals</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Concatenate</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">)</span>
</pre></div>
</div>
<p>Concatenate</p>
<p>Concatenate an arbitrary Python sequence into an array.
op is a python object supporting the sequence interface.
Its elements will be concatenated together to form a single
multidimensional array. If axis is NPY_MAXDIMS or bigger, then
each sequence object will be flattened before concatenation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_InnerProduct</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">op2</span><span class="p">)</span>
</pre></div>
</div>
<p>Numeric.innerproduct(a,v)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_MatrixProduct</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">op2</span><span class="p">)</span>
</pre></div>
</div>
<p>Numeric.matrixproduct(a,v)
just like inner product but does the swapaxes stuff on the fly</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_CopyAndTranspose</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
<p>Copy and Transpose</p>
<p>Could deprecate this function, as there isn’t a speed benefit over
calling Transpose and then Copy.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Correlate</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">op2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">mode</span><span class="p">)</span>
</pre></div>
</div>
<p>Numeric.correlate(a1,a2,mode)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_TypestrConvert</span><span class="p">(</span><span class="nb">int</span> <span class="n">itemsize</span><span class="p">,</span> <span class="nb">int</span> <span class="n">gentype</span><span class="p">)</span>
</pre></div>
</div>
<p>Typestr converter</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_DescrConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">**</span><span class="n">at</span><span class="p">)</span>
</pre></div>
</div>
<p>Get typenum from an object – None goes to NPY_DEFAULT_TYPE
This function takes a Python object representing a type and converts it
to a the correct PyArray_Descr * structure to describe the type.</p>
<p>Many objects can be used to represent a data-type which in NumPy is
quite a flexible concept.</p>
<p>This is the central code that converts Python objects to
Type-descriptor objects that are used throughout numpy.</p>
<p>Returns a new reference in <a href="#id5"><span class="problematic" id="id6">*</span></a>at, but the returned should not be
modified as it may be one of the canonical immutable objects or
a reference to the input obj.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_DescrConverter2</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">**</span><span class="n">at</span><span class="p">)</span>
</pre></div>
</div>
<p>Get typenum from an object – None goes to NULL</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_IntpConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyArray_Dims</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
</pre></div>
</div>
<p>Get intp chunk from sequence</p>
<p>This function takes a Python sequence object and allocates and
fills in an intp array with the converted values.</p>
<p>Remember to free the pointer seq.ptr when done using
PyDimMem_FREE(seq.ptr)**</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_BufferConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyArray_Chunk</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
</pre></div>
</div>
<p>Get buffer chunk from object</p>
<p>this function takes a Python object which exposes the (single-segment)
buffer interface and returns a pointer to the data segment</p>
<p>You should increment the reference count by one of buf-&gt;base
if you will hang on to a reference</p>
<p>You only get a borrowed reference to the object. Do not free the
memory…</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_AxisConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">axis</span><span class="p">)</span>
</pre></div>
</div>
<p>Get axis from an object (possibly None) – a converter function,</p>
<p>See also PyArray_ConvertMultiAxis, which also handles a tuple of axes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_BoolConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="nb">object</span><span class="p">,</span> <span class="n">npy_bool</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert an object to true / false</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_ByteorderConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">endian</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert object to endian</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_OrderConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="nb">object</span><span class="p">,</span> <span class="n">NPY_ORDER</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert an object to FORTRAN / C / ANY / KEEP</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">char</span>
<span class="n">PyArray_EquivTypes</span><span class="p">(</span><span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">type1</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">type2</span><span class="p">)</span>
</pre></div>
</div>
<p>This function returns true if the two typecodes are
equivalent (same basic kind and same itemsize).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Zeros</span><span class="p">(</span><span class="nb">int</span> <span class="n">nd</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">dims</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="nb">type</span><span class="p">,</span> <span class="nb">int</span>
              <span class="n">is_f_order</span><span class="p">)</span>
</pre></div>
</div>
<p>Zeros</p>
<p>steals a reference to type. On failure or when dtype-&gt;subarray is
true, dtype will be decrefed.
accepts NULL type</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Empty</span><span class="p">(</span><span class="nb">int</span> <span class="n">nd</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">dims</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="nb">type</span><span class="p">,</span> <span class="nb">int</span>
              <span class="n">is_f_order</span><span class="p">)</span>
</pre></div>
</div>
<p>Empty</p>
<p>accepts NULL type
steals a reference to type</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Where</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">condition</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Arange</span><span class="p">(</span><span class="n">double</span> <span class="n">start</span><span class="p">,</span> <span class="n">double</span> <span class="n">stop</span><span class="p">,</span> <span class="n">double</span> <span class="n">step</span><span class="p">,</span> <span class="nb">int</span> <span class="n">type_num</span><span class="p">)</span>
</pre></div>
</div>
<p>Arange,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_ArangeObj</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">stop</span><span class="p">,</span> <span class="n">PyObject</span>
                  <span class="o">*</span><span class="n">step</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
<p>ArangeObj,</p>
<p>this doesn’t change the references</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_SortkindConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">NPY_SORTKIND</span> <span class="o">*</span><span class="n">sortkind</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert object to sort kind</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_LexSort</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">sort_keys</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">)</span>
</pre></div>
</div>
<p>LexSort an array providing indices that will sort a collection of arrays
lexicographically.  The first key is sorted on first, followed by the second key
– requires that arg”merge”sort is available for each sort_key</p>
<p>Returns an index array that shows the indexes for the lexicographic sort along
the given axis.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Round</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Round</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">char</span>
<span class="n">PyArray_EquivTypenums</span><span class="p">(</span><span class="nb">int</span> <span class="n">typenum1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">typenum2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_RegisterDataType</span><span class="p">(</span><span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">)</span>
</pre></div>
</div>
<p>Register Data type
Does not change the reference count of descr</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_RegisterCastFunc</span><span class="p">(</span><span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="nb">int</span>
                         <span class="n">totype</span><span class="p">,</span> <span class="n">PyArray_VectorUnaryFunc</span> <span class="o">*</span><span class="n">castfunc</span><span class="p">)</span>
</pre></div>
</div>
<p>Register Casting Function
Replaces any function currently stored.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_RegisterCanCast</span><span class="p">(</span><span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="nb">int</span>
                        <span class="n">totype</span><span class="p">,</span> <span class="n">NPY_SCALARKIND</span> <span class="n">scalar</span><span class="p">)</span>
</pre></div>
</div>
<p>Register a type number indicating that a descriptor can be cast
to it safely</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_InitArrFuncs</span><span class="p">(</span><span class="n">PyArray_ArrFuncs</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialize arrfuncs to NULL</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_IntTupleFromIntp</span><span class="p">(</span><span class="nb">int</span> <span class="nb">len</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">vals</span><span class="p">)</span>
</pre></div>
</div>
<p>PyArray_IntTupleFromIntp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_TypeNumFromName</span><span class="p">(</span><span class="n">char</span> <span class="n">const</span> <span class="o">*</span><span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_ClipmodeConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="nb">object</span><span class="p">,</span> <span class="n">NPY_CLIPMODE</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert an object to NPY_RAISE / NPY_CLIP / NPY_WRAP</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_OutputConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="nb">object</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">**</span><span class="n">address</span><span class="p">)</span>
</pre></div>
</div>
<p>Useful to pass as converter function for O&amp; processing in
PyArgs_ParseTuple for output arrays</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_BroadcastToShape</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="o">*</span><span class="n">dims</span><span class="p">,</span> <span class="nb">int</span> <span class="n">nd</span><span class="p">)</span>
</pre></div>
</div>
<p>Get Iterator broadcast to a particular shape</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">_PyArray_SigintHandler</span><span class="p">(</span><span class="nb">int</span> <span class="n">signum</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span><span class="o">*</span>
<span class="n">_PyArray_GetSigintBuf</span><span class="p">(</span><span class="n">void</span> <span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_DescrAlignConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">**</span><span class="n">at</span><span class="p">)</span>
</pre></div>
</div>
<p>Get type-descriptor from an object forcing alignment if possible
None goes to DEFAULT type.</p>
<p>any object with the .fields attribute and/or .itemsize attribute (if the
.fields attribute does not give the total size – i.e. a partial record
naming).  If itemsize is given it must be &gt;= size computed from fields</p>
<p>The .fields attribute must return a convertible dictionary if present.
Result inherits from NPY_VOID.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_DescrAlignConverter2</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">**</span><span class="n">at</span><span class="p">)</span>
</pre></div>
</div>
<p>Get type-descriptor from an object forcing alignment if possible
None goes to NULL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_SearchsideConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert object to searchsorted side</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_CheckAxis</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span> <span class="n">flags</span><span class="p">)</span>
</pre></div>
</div>
<p>PyArray_CheckAxis</p>
<p>check that axis is valid
convert 0-d arrays to 1-d arrays</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span>
<span class="n">PyArray_OverflowMultiplyList</span><span class="p">(</span><span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">l1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Multiply a List of Non-negative numbers with over-flow detection.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CompareString</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">s2</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="o">*</span>
<span class="n">PyArray_MultiIterFromObjects</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">**</span><span class="n">mps</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="nb">int</span> <span class="n">nadd</span><span class="p">,</span> <span class="o">...</span> <span class="p">)</span>
</pre></div>
</div>
<p>Get MultiIterator from array of Python objects and any additional</p>
<p>PyObject <a href="#id7"><span class="problematic" id="id8">**</span></a>mps - array of PyObjects
int n - number of PyObjects in the array
int nadd - number of additional arrays to include in the iterator.</p>
<p>Returns a multi-iterator object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_GetEndianness</span><span class="p">(</span><span class="n">void</span> <span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="nb">int</span>
<span class="n">PyArray_GetNDArrayCFeatureVersion</span><span class="p">(</span><span class="n">void</span> <span class="p">)</span>
</pre></div>
</div>
<p>Returns the built-in (at compilation time) C API version</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_Correlate2</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">op2</span><span class="p">,</span> <span class="nb">int</span> <span class="n">mode</span><span class="p">)</span>
</pre></div>
</div>
<p>correlate(a1,a2,mode)</p>
<p>This function computes the usual correlation (correlate(a1, a2) !=
correlate(a2, a1), and conjugate the second argument for complex inputs</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="o">*</span>
<span class="n">PyArray_NeighborhoodIterNew</span><span class="p">(</span><span class="n">PyArrayIterObject</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">const</span> <span class="n">npy_intp</span>
                            <span class="o">*</span><span class="n">bounds</span><span class="p">,</span> <span class="nb">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">PyArrayObject</span><span class="o">*</span><span class="n">fill</span><span class="p">)</span>
</pre></div>
</div>
<p>A Neighborhood Iterator object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_SetDatetimeParseFunction</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>This function is scheduled to be removed</p>
<p>TO BE REMOVED - NOT USED INTERNALLY.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_DatetimeToDatetimeStruct</span><span class="p">(</span><span class="n">npy_datetime</span> <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                                 <span class="p">,</span> <span class="n">NPY_DATETIMEUNIT</span> <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span>
                                 <span class="p">,</span> <span class="n">npy_datetimestruct</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Fill the datetime struct from the value and resolution unit.</p>
<p>TO BE REMOVED - NOT USED INTERNALLY.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_TimedeltaToTimedeltaStruct</span><span class="p">(</span><span class="n">npy_timedelta</span> <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                                   <span class="p">,</span> <span class="n">NPY_DATETIMEUNIT</span> <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span>
                                   <span class="p">,</span> <span class="n">npy_timedeltastruct</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Fill the timedelta struct from the timedelta value and resolution unit.</p>
<p>TO BE REMOVED - NOT USED INTERNALLY.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_datetime</span>
<span class="n">PyArray_DatetimeStructToDatetime</span><span class="p">(</span><span class="n">NPY_DATETIMEUNIT</span> <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span>
                                 <span class="p">,</span> <span class="n">npy_datetimestruct</span> <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Create a datetime value from a filled datetime struct and resolution unit.</p>
<p>TO BE REMOVED - NOT USED INTERNALLY.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_datetime</span>
<span class="n">PyArray_TimedeltaStructToTimedelta</span><span class="p">(</span><span class="n">NPY_DATETIMEUNIT</span> <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span>
                                   <span class="p">,</span> <span class="n">npy_timedeltastruct</span>
                                   <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Create a timdelta value from a filled timedelta struct and resolution unit.</p>
<p>TO BE REMOVED - NOT USED INTERNALLY.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter</span> <span class="o">*</span>
<span class="n">NpyIter_New</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">npy_uint32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">NPY_ORDER</span>
            <span class="n">order</span><span class="p">,</span> <span class="n">NPY_CASTING</span> <span class="n">casting</span><span class="p">,</span> <span class="n">PyArray_Descr</span><span class="o">*</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
<p>Allocate a new iterator for one array object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter</span> <span class="o">*</span>
<span class="n">NpyIter_MultiNew</span><span class="p">(</span><span class="nb">int</span> <span class="n">nop</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">**</span><span class="n">op_in</span><span class="p">,</span> <span class="n">npy_uint32</span>
                 <span class="n">flags</span><span class="p">,</span> <span class="n">NPY_ORDER</span> <span class="n">order</span><span class="p">,</span> <span class="n">NPY_CASTING</span>
                 <span class="n">casting</span><span class="p">,</span> <span class="n">npy_uint32</span> <span class="o">*</span><span class="n">op_flags</span><span class="p">,</span> <span class="n">PyArray_Descr</span>
                 <span class="o">**</span><span class="n">op_request_dtypes</span><span class="p">)</span>
</pre></div>
</div>
<p>Allocate a new iterator for more than one array object, using
standard NumPy broadcasting rules and the default buffer size.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter</span> <span class="o">*</span>
<span class="n">NpyIter_AdvancedNew</span><span class="p">(</span><span class="nb">int</span> <span class="n">nop</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">**</span><span class="n">op_in</span><span class="p">,</span> <span class="n">npy_uint32</span>
                    <span class="n">flags</span><span class="p">,</span> <span class="n">NPY_ORDER</span> <span class="n">order</span><span class="p">,</span> <span class="n">NPY_CASTING</span>
                    <span class="n">casting</span><span class="p">,</span> <span class="n">npy_uint32</span> <span class="o">*</span><span class="n">op_flags</span><span class="p">,</span> <span class="n">PyArray_Descr</span>
                    <span class="o">**</span><span class="n">op_request_dtypes</span><span class="p">,</span> <span class="nb">int</span> <span class="n">oa_ndim</span><span class="p">,</span> <span class="nb">int</span>
                    <span class="o">**</span><span class="n">op_axes</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="o">*</span><span class="n">itershape</span><span class="p">,</span> <span class="n">npy_intp</span>
                    <span class="n">buffersize</span><span class="p">)</span>
</pre></div>
</div>
<p>Allocate a new iterator for multiple array objects, and advanced
options for controlling the broadcasting, shape, and buffer size.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter</span> <span class="o">*</span>
<span class="n">NpyIter_Copy</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Makes a copy of the iterator</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_Deallocate</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Deallocate an iterator.</p>
<p>To correctly work when an error is in progress, we have to check
<cite>PyErr_Occurred()</cite>. This is necessary when buffers are not finalized
or WritebackIfCopy is used. We could avoid that check by exposing a new
function which is passed in whether or not a Python error is already set.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">NpyIter_HasDelayedBufAlloc</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Whether the buffer allocation is being delayed</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">NpyIter_HasExternalLoop</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Whether the iterator handles the inner loop</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_EnableExternalLoop</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Removes the inner loop handling (so HasExternalLoop returns true)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span> <span class="o">*</span>
<span class="n">NpyIter_GetInnerStrideArray</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the array of strides for the inner loop (when HasExternalLoop is true)</p>
<p>This function may be safely called without holding the Python GIL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span> <span class="o">*</span>
<span class="n">NpyIter_GetInnerLoopSizePtr</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Get a pointer to the size of the inner loop  (when HasExternalLoop is true)</p>
<p>This function may be safely called without holding the Python GIL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_Reset</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">errmsg</span><span class="p">)</span>
</pre></div>
</div>
<p>Resets the iterator to its initial state</p>
<p>The use of errmsg is discouraged, it cannot be guaranteed that the GIL
will not be grabbed on casting errors even when this is passed.</p>
<p>If errmsg is non-NULL, it should point to a variable which will
receive the error message, and no Python exception will be set.
This is so that the function can be called from code not holding
the GIL. Note that cast errors may still lead to the GIL being
grabbed temporarily.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_ResetBasePointers</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">baseptrs</span><span class="p">,</span> <span class="n">char</span>
                          <span class="o">**</span><span class="n">errmsg</span><span class="p">)</span>
</pre></div>
</div>
<p>Resets the iterator to its initial state, with new base data pointers.
This function requires great caution.</p>
<p>If errmsg is non-NULL, it should point to a variable which will
receive the error message, and no Python exception will be set.
This is so that the function can be called from code not holding
the GIL. Note that cast errors may still lead to the GIL being
grabbed temporarily.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_ResetToIterIndexRange</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">istart</span><span class="p">,</span> <span class="n">npy_intp</span>
                              <span class="n">iend</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">errmsg</span><span class="p">)</span>
</pre></div>
</div>
<p>Resets the iterator to a new iterator index range</p>
<p>If errmsg is non-NULL, it should point to a variable which will
receive the error message, and no Python exception will be set.
This is so that the function can be called from code not holding
the GIL. Note that cast errors may still lead to the GIL being
grabbed temporarily.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_GetNDim</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Gets the number of dimensions being iterated</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_GetNOp</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Gets the number of operands being iterated</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter_IterNextFunc</span> <span class="o">*</span>
<span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">errmsg</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the specialized iteration function for an iterator</p>
<p>If errmsg is non-NULL, it should point to a variable which will
receive the error message, and no Python exception will be set.
This is so that the function can be called from code not holding
the GIL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span>
<span class="n">NpyIter_GetIterSize</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Gets the number of elements being iterated</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">NpyIter_GetIterIndexRange</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="o">*</span><span class="n">istart</span><span class="p">,</span> <span class="n">npy_intp</span>
                          <span class="o">*</span><span class="n">iend</span><span class="p">)</span>
</pre></div>
</div>
<p>Gets the range of iteration indices being iterated</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span>
<span class="n">NpyIter_GetIterIndex</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Gets the current iteration index</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_GotoIterIndex</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">iterindex</span><span class="p">)</span>
</pre></div>
</div>
<p>Sets the iterator position to the specified iterindex,
which matches the iteration order of the iterator.</p>
<p>Returns NPY_SUCCEED on success, NPY_FAIL on failure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">NpyIter_HasMultiIndex</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Whether the iterator is tracking a multi-index</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_GetShape</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="o">*</span><span class="n">outshape</span><span class="p">)</span>
</pre></div>
</div>
<p>Gets the broadcast shape if a multi-index is being tracked by the iterator,
otherwise gets the shape of the iteration as Fortran-order
(fastest-changing index first).</p>
<p>The reason Fortran-order is returned when a multi-index
is not enabled is that this is providing a direct view into how
the iterator traverses the n-dimensional space. The iterator organizes
its memory from fastest index to slowest index, and when
a multi-index is enabled, it uses a permutation to recover the original
order.</p>
<p>Returns NPY_SUCCEED or NPY_FAIL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter_GetMultiIndexFunc</span> <span class="o">*</span>
<span class="n">NpyIter_GetGetMultiIndex</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">errmsg</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute a specialized get_multi_index function for the iterator</p>
<p>If errmsg is non-NULL, it should point to a variable which will
receive the error message, and no Python exception will be set.
This is so that the function can be called from code not holding
the GIL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_GotoMultiIndex</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span> <span class="o">*</span><span class="n">multi_index</span><span class="p">)</span>
</pre></div>
</div>
<p>Sets the iterator to the specified multi-index, which must have the
correct number of entries for ‘ndim’.  It is only valid
when NPY_ITER_MULTI_INDEX was passed to the constructor.  This operation
fails if the multi-index is out of bounds.</p>
<p>Returns NPY_SUCCEED on success, NPY_FAIL on failure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_RemoveMultiIndex</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Removes multi-index support from an iterator.</p>
<p>Returns NPY_SUCCEED or NPY_FAIL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">NpyIter_HasIndex</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Whether the iterator is tracking an index</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">NpyIter_IsBuffered</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Whether the iterator is buffered</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">NpyIter_IsGrowInner</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Whether the inner loop can grow if buffering is unneeded</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span>
<span class="n">NpyIter_GetBufferSize</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Gets the size of the buffer, or 0 if buffering is not enabled</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span> <span class="o">*</span>
<span class="n">NpyIter_GetIndexPtr</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Get a pointer to the index, if it is being tracked</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_GotoIndex</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">flat_index</span><span class="p">)</span>
</pre></div>
</div>
<p>If the iterator is tracking an index, sets the iterator
to the specified index.</p>
<p>Returns NPY_SUCCEED on success, NPY_FAIL on failure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="o">**</span>
<span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the array of data pointers (1 per object being iterated)</p>
<p>This function may be safely called without holding the Python GIL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span> <span class="o">**</span>
<span class="n">NpyIter_GetDescrArray</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the array of data type pointers (1 per object being iterated)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArrayObject</span> <span class="o">**</span>
<span class="n">NpyIter_GetOperandArray</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the array of objects being iterated</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArrayObject</span> <span class="o">*</span>
<span class="n">NpyIter_GetIterView</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns a view to the i-th object with the iterator’s internal axes</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">NpyIter_GetReadFlags</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">outreadflags</span><span class="p">)</span>
</pre></div>
</div>
<p>Gets an array of read flags (1 per object being iterated)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">NpyIter_GetWriteFlags</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">outwriteflags</span><span class="p">)</span>
</pre></div>
</div>
<p>Gets an array of write flags (1 per object being iterated)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">NpyIter_DebugPrint</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>For debugging</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">NpyIter_IterationNeedsAPI</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Whether the iteration loop, and in particular the iternext()
function, needs API access.  If this is true, the GIL must
be retained while iterating.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">NpyIter_GetInnerFixedStrideArray</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="o">*</span><span class="n">out_strides</span><span class="p">)</span>
</pre></div>
</div>
<p>Get an array of strides which are fixed.  Any strides which may
change during iteration receive the value NPY_MAX_INTP.  Once
the iterator is ready to iterate, call this to get the strides
which will always be fixed in the inner loop, then choose optimized
inner loop functions which take advantage of those fixed strides.</p>
<p>This function may be safely called without holding the Python GIL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_RemoveAxis</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">)</span>
</pre></div>
</div>
<p>Removes an axis from iteration. This requires that NPY_ITER_MULTI_INDEX
was set for iterator creation, and does not work if buffering is
enabled. This function also resets the iterator to its initial state.</p>
<p>Returns NPY_SUCCEED or NPY_FAIL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span> <span class="o">*</span>
<span class="n">NpyIter_GetAxisStrideArray</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="nb">int</span> <span class="n">axis</span><span class="p">)</span>
</pre></div>
</div>
<p>Gets the array of strides for the specified axis.
If the iterator is tracking a multi-index, gets the strides
for the axis specified, otherwise gets the strides for
the iteration axis as Fortran order (fastest-changing axis first).</p>
<p>Returns NULL if an error occurs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">NpyIter_RequiresBuffering</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Whether the iteration could be done with no buffering.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="o">**</span>
<span class="n">NpyIter_GetInitialDataPtrArray</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the array of data pointers (1 per object being iterated),
directly into the arrays (never pointing to a buffer), for starting
unbuffered iteration. This always returns the addresses for the
iterator position as reset to iterator index 0.</p>
<p>These pointers are different from the pointers accepted by
NpyIter_ResetBasePointers, because the direction along some
axes may have been reversed, requiring base offsets.</p>
<p>This function may be safely called without holding the Python GIL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">NpyIter_CreateCompatibleStrides</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="n">npy_intp</span>
                                <span class="n">itemsize</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="o">*</span><span class="n">outstrides</span><span class="p">)</span>
</pre></div>
</div>
<p>Builds a set of strides which are the same as the strides of an
output array created using the NPY_ITER_ALLOCATE flag, where NULL
was passed for op_axes.  This is for data packed contiguously,
but not necessarily in C or Fortran order. This should be used
together with NpyIter_GetShape and NpyIter_GetNDim.</p>
<p>A use case for this function is to match the shape and layout of
the iterator and tack on one or more dimensions.  For example,
in order to generate a vector per input value for a numerical gradient,
you pass in ndim*itemsize for itemsize, then add another dimension to
the end with size ndim and stride itemsize.  To do the Hessian matrix,
you do the same thing but add two dimensions, or take advantage of
the symmetry and pack it into 1 dimension with a particular encoding.</p>
<p>This function may only be called if the iterator is tracking a multi-index
and if NPY_ITER_DONT_NEGATE_STRIDES was used to prevent an axis from
being iterated in reverse order.</p>
<p>If an array is created with this method, simply adding ‘itemsize’
for each iteration will traverse the new array matching the
iterator.</p>
<p>Returns NPY_SUCCEED or NPY_FAIL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CastingConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">NPY_CASTING</span> <span class="o">*</span><span class="n">casting</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert any Python object, <em>obj</em>, to an NPY_CASTING enum.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span>
<span class="n">PyArray_CountNonzero</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Counts the number of non-zero elements in the array.</p>
<p>Returns -1 on error.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span> <span class="o">*</span>
<span class="n">PyArray_PromoteTypes</span><span class="p">(</span><span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">type1</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">type2</span><span class="p">)</span>
</pre></div>
</div>
<p>Produces the smallest size and lowest kind type to which both
input types can be cast.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span> <span class="o">*</span>
<span class="n">PyArray_MinScalarType</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
<p>If arr is a scalar (has 0 dimensions) with a built-in number data type,
finds the smallest type size/kind which can still represent its data.
Otherwise, returns the array’s data type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span> <span class="o">*</span>
<span class="n">PyArray_ResultType</span><span class="p">(</span><span class="n">npy_intp</span> <span class="n">narrs</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arrs</span><span class="p">[]</span> <span class="p">,</span> <span class="n">npy_intp</span>
                   <span class="n">ndtypes</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">descrs</span><span class="p">[]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Produces the result type of a bunch of inputs, using the same rules
as <cite>np.result_type</cite>.</p>
<p>NOTE: This function is expected to through a transitional period or
change behaviour.  DTypes should always be strictly enforced for
0-D arrays, while “weak DTypes” will be used to represent Python
integers, floats, and complex in all cases.
(Within this function, these are currently flagged on the array
object to work through <cite>np.result_type</cite>, this may change.)</p>
<p>Until a time where this transition is complete, we probably cannot
add new “weak DTypes” or allow users to create their own.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">PyArray_CanCastArrayTo</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="n">PyArray_Descr</span>
                       <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="n">NPY_CASTING</span> <span class="n">casting</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns 1 if the array object may be cast to the given data type using
the casting rule, 0 otherwise.  This differs from PyArray_CanCastTo in
that it handles scalar arrays (0 dimensions) specially, by checking
their value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">PyArray_CanCastTypeTo</span><span class="p">(</span><span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="n">PyArray_Descr</span>
                      <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="n">NPY_CASTING</span> <span class="n">casting</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns true if data of type ‘from’ may be cast to data of type
‘to’ according to the rule ‘casting’.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyArrayObject</span> <span class="o">*</span>
<span class="n">PyArray_EinsteinSum</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">subscripts</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">nop</span><span class="p">,</span> <span class="n">PyArrayObject</span>
                    <span class="o">**</span><span class="n">op_in</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">dtype</span><span class="p">,</span> <span class="n">NPY_ORDER</span>
                    <span class="n">order</span><span class="p">,</span> <span class="n">NPY_CASTING</span> <span class="n">casting</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>This function provides summation of array elements according to
the Einstein summation convention.  For example:
- trace(a)        -&gt; einsum(“ii”, a)
- transpose(a)    -&gt; einsum(“ji”, a)
- multiply(a,b)   -&gt; einsum(“,”, a, b)
- inner(a,b)      -&gt; einsum(“i,i”, a, b)
- outer(a,b)      -&gt; einsum(“i,j”, a, b)
- matvec(a,b)     -&gt; einsum(“ij,j”, a, b)
- matmat(a,b)     -&gt; einsum(“ij,jk”, a, b)</p>
<p>subscripts: The string of subscripts for einstein summation.
nop:        The number of operands
op_in:      The array of operands
dtype:      Either NULL, or the data type to force the calculation as.
order:      The order for the calculation/the output axes.
casting:    What kind of casts should be permitted.
out:        Either NULL, or an array into which the output should be placed.</p>
<p>By default, the labels get placed in alphabetical order
at the end of the output. So, if c = einsum(“i,j”, a, b)
then c[i,j] == a[i]*b[j], but if c = einsum(“j,i”, a, b)
then c[i,j] = a[j]*b[i].</p>
<p>Alternatively, you can control the output order or prevent
an axis from being summed/force an axis to be summed by providing
indices for the output. This allows us to turn ‘trace’ into
‘diag’, for example.
- diag(a)         -&gt; einsum(“ii-&gt;i”, a)
- sum(a, axis=0)  -&gt; einsum(“i…-&gt;”, a)</p>
<p>Subscripts at the beginning and end may be specified by
putting an ellipsis “…” in the middle.  For example,
the function einsum(“i…i”, a) takes the diagonal of
the first and last dimensions of the operand, and
einsum(“ij…,jk…-&gt;ik…”) takes the matrix product using
the first two indices of each operand instead of the last two.</p>
<p>When there is only one operand, no axes being summed, and
no output parameter, this function returns a view
into the operand instead of making a copy.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_NewLikeArray</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">prototype</span><span class="p">,</span> <span class="n">NPY_ORDER</span>
                     <span class="n">order</span><span class="p">,</span> <span class="n">PyArray_Descr</span> <span class="o">*</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">int</span> <span class="n">subok</span><span class="p">)</span>
</pre></div>
</div>
<p>Creates a new array with the same shape as the provided one,
with possible memory layout order and data type changes.</p>
<p>prototype - The array the new one should be like.
order     - NPY_CORDER - C-contiguous result.
NPY_FORTRANORDER - Fortran-contiguous result.
NPY_ANYORDER - Fortran if prototype is Fortran, C otherwise.
NPY_KEEPORDER - Keeps the axis ordering of prototype.
dtype     - If not NULL, overrides the data type of the result.
subok     - If 1, use the prototype’s array subtype, otherwise
always create a base-class array.</p>
<p>NOTE: If dtype is not NULL, steals the dtype reference.  On failure or when
dtype-&gt;subarray is true, dtype will be decrefed.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_GetArrayParamsFromObject</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                                 <span class="p">,</span> <span class="n">PyArray_Descr</span>
                                 <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">requested_dtype</span><span class="p">)</span>
                                 <span class="p">,</span> <span class="n">npy_bool</span> <span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">writeable</span><span class="p">)</span>
                                 <span class="p">,</span> <span class="n">PyArray_Descr</span>
                                 <span class="o">**</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span> <span class="p">,</span> <span class="nb">int</span>
                                 <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">out_ndim</span><span class="p">)</span> <span class="p">,</span> <span class="n">npy_intp</span>
                                 <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">out_dims</span><span class="p">)</span> <span class="p">,</span> <span class="n">PyArrayObject</span>
                                 <span class="o">**</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">out_arr</span><span class="p">)</span> <span class="p">,</span> <span class="n">PyObject</span>
                                 <span class="o">*</span><span class="n">NPY_UNUSED</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_ConvertClipmodeSequence</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="nb">object</span><span class="p">,</span> <span class="n">NPY_CLIPMODE</span>
                                <span class="o">*</span><span class="n">modes</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert an object to an array of n NPY_CLIPMODE values.
This is intended to be used in functions where a different mode
could be applied to each axis, like in ravel_multi_index.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_MatrixProduct2</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">PyObject</span>
                       <span class="o">*</span><span class="n">op2</span><span class="p">,</span> <span class="n">PyArrayObject</span><span class="o">*</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Numeric.matrixproduct2(a,v,out)
just like inner product but does the swapaxes stuff on the fly</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npy_bool</span>
<span class="n">NpyIter_IsFirstVisit</span><span class="p">(</span><span class="n">NpyIter</span> <span class="o">*</span><span class="nb">iter</span><span class="p">,</span> <span class="nb">int</span> <span class="n">iop</span><span class="p">)</span>
</pre></div>
</div>
<p>Checks to see whether this is the first time the elements
of the specified reduction operand which the iterator points at are
being seen for the first time. The function returns
a reasonable answer for reduction operands and when buffering is
disabled. The answer may be incorrect for buffered non-reduction
operands.</p>
<p>This function is intended to be used in EXTERNAL_LOOP mode only,
and will produce some wrong answers when that mode is not enabled.</p>
<p>If this function returns true, the caller should also
check the inner loop stride of the operand, because if
that stride is 0, then only the first element of the innermost
external loop is being visited for the first time.</p>
<p>WARNING: For performance reasons, ‘iop’ is not bounds-checked,
it is not confirmed that ‘iop’ is actually a reduction
operand, and it is not confirmed that EXTERNAL_LOOP
mode is enabled. These checks are the responsibility of
the caller, and should be done outside of any inner loops.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_SetBaseObject</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>Sets the ‘base’ attribute of the array. This steals a reference
to ‘obj’.</p>
<p>Returns 0 on success, -1 on failure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_CreateSortedStridePerm</span><span class="p">(</span><span class="nb">int</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">npy_intp</span> <span class="n">const</span>
                               <span class="o">*</span><span class="n">strides</span><span class="p">,</span> <span class="n">npy_stride_sort_item</span>
                               <span class="o">*</span><span class="n">out_strideperm</span><span class="p">)</span>
</pre></div>
</div>
<p>This function populates the first ndim elements
of strideperm with sorted descending by their absolute values.
For example, the stride array (4, -2, 12) becomes
[(2, 12), (0, 4), (1, -2)].</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_RemoveAxesInPlace</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="n">const</span> <span class="n">npy_bool</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
</pre></div>
</div>
<p>Removes the axes flagged as True from the array,
modifying it in place. If an axis flagged for removal
has a shape entry bigger than one, this effectively selects
index zero for that axis.</p>
<p>WARNING: If an axis flagged for removal has a shape equal to zero,
the array will point to invalid memory. The caller must
validate this!
If an axis flagged for removal has a shape larger than one,
the aligned flag (and in the future the contiguous flags),
may need explicit update.
(check also NPY_RELAXED_STRIDES_CHECKING)</p>
<p>For example, this can be used to remove the reduction axes
from a reduction result once its computation is complete.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_DebugPrint</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>Prints the raw data of the ndarray in a form useful for debugging
low-level C issues.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_FailUnlessWriteable</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>This function does nothing if obj is writeable, and raises an exception
(and returns -1) if obj is not writeable. It may also do other
house-keeping, such as issuing warnings on arrays which are transitioning
to become views. Always call this function at some point before writing to
an array.</p>
<p>‘name’ is a name for the array, used to give better error
messages. Something like “assignment destination”, “output array”, or even
just “array”.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_SetUpdateIfCopyBase</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
</pre></div>
</div>
<p>Precondition: ‘arr’ is a copy of ‘base’ (though possibly with different
strides, ordering, etc.). This function sets the UPDATEIFCOPY flag and the
-&gt;base pointer on ‘arr’, so that when ‘arr’ is destructed, it will copy any
changes back to ‘base’. DEPRECATED, use PyArray_SetWritebackIfCopyBase</p>
<p>Steals a reference to ‘base’.</p>
<p>Returns 0 on success, -1 on failure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="o">*</span>
<span class="n">PyDataMem_NEW</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<p>Allocates memory for array data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyDataMem_FREE</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
</pre></div>
</div>
<p>Free memory for array data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="o">*</span>
<span class="n">PyDataMem_RENEW</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<p>Reallocate/resize memory for array data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyDataMem_EventHookFunc</span> <span class="o">*</span>
<span class="n">PyDataMem_SetEventHook</span><span class="p">(</span><span class="n">PyDataMem_EventHookFunc</span> <span class="o">*</span><span class="n">newhook</span><span class="p">,</span> <span class="n">void</span>
                       <span class="o">*</span><span class="n">user_data</span><span class="p">,</span> <span class="n">void</span> <span class="o">**</span><span class="n">old_data</span><span class="p">)</span>
</pre></div>
</div>
<p>Sets the allocation event hook for numpy array data.
Takes a PyDataMem_EventHookFunc <a href="#id9"><span class="problematic" id="id10">*</span></a>, which has the signature:
void hook(void <a href="#id11"><span class="problematic" id="id12">*</span></a>old, void <a href="#id13"><span class="problematic" id="id14">*</span></a>new, size_t size, void <a href="#id15"><span class="problematic" id="id16">*</span></a>user_data).
Also takes a void <a href="#id17"><span class="problematic" id="id18">*</span></a>user_data, and void <a href="#id19"><span class="problematic" id="id20">**</span></a>old_data.</p>
<p>Returns a pointer to the previous hook or NULL.  If old_data is
non-NULL, the previous user_data pointer will be copied to it.</p>
<p>If not NULL, hook will be called at the end of each PyDataMem_NEW/FREE/RENEW:
result = PyDataMem_NEW(size)        -&gt; (<a href="#id21"><span class="problematic" id="id22">*</span></a>hook)(NULL, result, size, user_data)
PyDataMem_FREE(ptr)                 -&gt; (<a href="#id23"><span class="problematic" id="id24">*</span></a>hook)(ptr, NULL, 0, user_data)
result = PyDataMem_RENEW(ptr, size) -&gt; (<a href="#id25"><span class="problematic" id="id26">*</span></a>hook)(ptr, result, size, user_data)</p>
<p>When the hook is called, the GIL will be held by the calling
thread.  The hook should be written to be reentrant, if it performs
operations that might cause new allocation events (such as the
creation/destruction numpy objects, or creating/destroying Python
objects which might cause a gc)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_MapIterSwapAxes</span><span class="p">(</span><span class="n">PyArrayMapIterObject</span> <span class="o">*</span><span class="n">mit</span><span class="p">,</span> <span class="n">PyArrayObject</span>
                        <span class="o">**</span><span class="n">ret</span><span class="p">,</span> <span class="nb">int</span> <span class="n">getmap</span><span class="p">)</span>
</pre></div>
</div>
<p>Swap the axes to or from their inserted form. MapIter always puts the
advanced (array) indices first in the iteration. But if they are
consecutive, will insert/transpose them back before returning.
This is stored as <cite>mit-&gt;consec != 0</cite> (the place where they are inserted)
For assignments, the opposite happens: The values to be assigned are
transposed (getmap=1 instead of getmap=0). <cite>getmap=0</cite> and <cite>getmap=1</cite>
undo the other operation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_MapIterArray</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
<p>Use advanced indexing to iterate an array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span>
<span class="n">PyArray_MapIterNext</span><span class="p">(</span><span class="n">PyArrayMapIterObject</span> <span class="o">*</span><span class="n">mit</span><span class="p">)</span>
</pre></div>
</div>
<p>This function needs to update the state of the map iterator
and point mit-&gt;dataptr to the memory-location of the next object</p>
<p>Note that this function never handles an extra operand but provides
compatibility for an old (exposed) API.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_Partition</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">ktharray</span><span class="p">,</span> <span class="nb">int</span>
                  <span class="n">axis</span><span class="p">,</span> <span class="n">NPY_SELECTKIND</span> <span class="n">which</span><span class="p">)</span>
</pre></div>
</div>
<p>Partition an array in-place</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_ArgPartition</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">ktharray</span><span class="p">,</span> <span class="nb">int</span>
                     <span class="n">axis</span><span class="p">,</span> <span class="n">NPY_SELECTKIND</span> <span class="n">which</span><span class="p">)</span>
</pre></div>
</div>
<p>ArgPartition an array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_SelectkindConverter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">NPY_SELECTKIND</span> <span class="o">*</span><span class="n">selectkind</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert object to select kind</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="o">*</span>
<span class="n">PyDataMem_NEW_ZEROED</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">elsize</span><span class="p">)</span>
</pre></div>
</div>
<p>Allocates zeroed memory for array data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_CheckAnyScalarExact</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>return true an object is exactly a numpy scalar</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="n">PyArray_MapIterArrayCopyIfOverlap</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">PyObject</span>
                                  <span class="o">*</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span>
                                  <span class="n">copy_if_overlap</span><span class="p">,</span> <span class="n">PyArrayObject</span>
                                  <span class="o">*</span><span class="n">extra_op</span><span class="p">)</span>
</pre></div>
</div>
<p>Same as PyArray_MapIterArray, but:</p>
<p>If copy_if_overlap != 0, check if <cite>a</cite> has memory overlap with any of the
arrays in <cite>index</cite> and with <cite>extra_op</cite>. If yes, make copies as appropriate
to avoid problems if <cite>a</cite> is modified during the iteration.
<cite>iter-&gt;array</cite> may contain a copied array (UPDATEIFCOPY/WRITEBACKIFCOPY set).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_ResolveWritebackIfCopy</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>If WRITEBACKIFCOPY and self has data, reset the base WRITEABLE flag,
copy the local data to base, release the local data, and set flags
appropriately. Return 0 if not relevant, 1 if success, &lt; 0 on failure</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span>
<span class="n">PyArray_SetWritebackIfCopyBase</span><span class="p">(</span><span class="n">PyArrayObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="n">PyArrayObject</span>
                               <span class="o">*</span><span class="n">base</span><span class="p">)</span>
</pre></div>
</div>
<p>Precondition: ‘arr’ is a copy of ‘base’ (though possibly with different
strides, ordering, etc.). This function sets the WRITEBACKIFCOPY flag and the
-&gt;base pointer on ‘arr’, call PyArray_ResolveWritebackIfCopy to copy any
changes back to ‘base’ before deallocating the array.</p>
<p>Steals a reference to ‘base’.</p>
<p>Returns 0 on success, -1 on failure.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2021, Davi Sidarta-Oliveira

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>