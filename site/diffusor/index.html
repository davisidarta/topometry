<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Diffusion harmonics - TopOMetry Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Diffusion harmonics";
    var mkdocs_page_input_path = "diffusor.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> TopOMetry Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Welcome!</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../installation/">Installation</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../quickstart/">Quick-start</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../TopOMetry_Intro_pbmc_10k/">Single-cell analysis</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../topograph/">The TopOGraph model</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Diffusion harmonics</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor">Diffusor</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor--parameters">Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor--example">Example</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.fit">fit()</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.fit--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.fit--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.ind_dist_grad">ind_dist_grad()</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.ind_dist_grad--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.ind_dist_grad--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.rescale">rescale()</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.rescale--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.rescale--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.spectrum_plot">spectrum_plot()</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.spectrum_plot--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.spectrum_plot--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#topo.tpgraph.diffusion.Diffusor.transform">transform()</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">TopOMetry Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Diffusion harmonics</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="documentation-for-diffusor">Documentation for <code>Diffusor</code></h1>


  <div class="doc doc-object doc-class">



<h2 id="topo.tpgraph.diffusion.Diffusor" class="doc doc-heading">
        <code>topo.tpgraph.diffusion.Diffusor</code>



</h2>

    <div class="doc doc-contents first">

      <p>Sklearn-compatible estimator for using fast anisotropic diffusion with an adaptive neighborhood search algorithm. The
Diffusion Maps algorithm was initially proposed by Coifman et al in 2005, and was augmented by the work of many.
This implementation aggregates recent advances in diffusion harmonics, and innovates only by implementing an
adaptively decaying kernel (the rate of decay is dependent on neighborhood density)
and an adaptive neighborhood estimation approach.</p>
<h4 id="topo.tpgraph.diffusion.Diffusor--parameters">Parameters</h4>
<p>n_eigs : int (optional, default 50)
    Number of diffusion components to compute. This number can be iterated to get different views
    from data at distinct spectral resolution.</p>
<p>use_eigs : int or str (optional, default 'knee')
    Number of eigenvectors to use. If 'max', expands to the maximum number of positive eigenvalues
    (reach of numerical precision), else to the maximum amount of computed components.
    If 'knee', uses Kneedle to find an optimal cutoff point, and expands it by <code>expansion</code>.
    If 'comp_gap', tries to find a discrete eigengap from the computation process.</p>
<p>n_neighbors : int (optional, default 10)
    Number of k-nearest-neighbors to compute. The adaptive kernel will normalize distances by each cell
    distance of its median neighbor. Nonetheless, this hyperparameter remains as an user input regarding
    the minimal sample neighborhood resolution that drives the computation of the diffusion metrics. For
    practical purposes, the minimum amount of samples one would expect to constitute a neighborhood of its
    own. Increasing <code>k</code> can generate more globally-comprehensive metrics and maps, to a certain extend,
    however at the expense of fine-grained resolution. More generally, consider this a calculus
    discretization threshold.</p>
<p>ann : bool (optional, default True)
    Whether to use approximate nearest neighbors for graph construction with NMSLib.
    If <code>False</code>, uses <code>sklearn</code> default implementation.</p>
<p>metric : str (optional, default 'cosine')
    Distance metric for building an approximate kNN graph. Defaults to 'euclidean'. Users are encouraged to explore
    different metrics, such as 'cosine' and 'jaccard'. The 'hamming' and 'jaccard' distances are also available
    for string vectors. Accepted metrics include NMSLib metrics and sklearn metrics. Some examples are:
    -'sqeuclidean'
    -'euclidean'
    -'l1'
    -'lp' - requires setting the parameter <code>p</code>
    -'cosine'
    -'angular'
    -'negdotprod'
    -'levenshtein'
    -'hamming'
    -'jaccard'
    -'jansen-shan'</p>
<p>p : int or float (optional, default 11/16 )
    P for the Lp metric, when <code>metric='lp'</code>.  Can be fractional. The default 11/16 approximates
    an astroid norm with some computational efficiency (2^n bases are less painstakinly slow to compute).
    See https://en.wikipedia.org/wiki/Lp_space for some context.</p>
<p>transitions : bool (optional, default False)
    Whether to estimate the diffusion transitions graph. If <code>True</code>, maps a basis encoding neighborhood
     transitions probability during eigendecomposition. If 'False' (default), maps the diffusion kernel.</p>
<p>alpha : int or float (optional, default 1)
    Alpha in the diffusion maps literature. Controls how much the results are biased by data distribution.
        Defaults to 1, which is suitable for normalized data.</p>
<p>kernel_use : str (optional, default 'decay_adaptive')
    Which type of kernel to use. There are four implemented, considering the adaptive decay and the
    neighborhood expansion, written as 'simple', 'decay', 'simple_adaptive' and 'decay_adaptive'. The first, 'simple'
    , is a locally-adaptive kernel similar to that proposed by Nadler et al.(https://doi.org/10.1016/j.acha.2005.07.004)
    and implemented in Setty et al. (https://doi.org/10.1038/s41587-019-0068-4). The 'decay' option applies an
    adaptive decay rate, but no neighborhood expansion. Those, followed by '_adaptive', apply the neighborhood expansion process.
     The default and recommended is 'decay_adaptive'.
    The neighborhood expansion can impact runtime, although this is not usually expressive for datasets under 10e6 samples.</p>
<p>transitions : bool (optional, default False)
    Whether to decompose the transition graph when transforming.
norm : bool (optional, default True)
    Whether to normalize the kernel transition probabilities to approximate the LPO.
eigengap : bool (optional, default True)
    Whether to expand the eigendecomposition a bit and stop if eigenvalues sign shift (limit of float64). Used
    to guarantee numerical stability.
n_jobs : int (optional, default 4)
    Number of threads to use in calculations. Defaults to 4 for safety, but performance
    scales dramatically when using more threads.
plot_spectrum : bool (optional, default False)
    Whether to plot the spectrum decay analysis.
verbose : bool (optional, default False)
    Controls verbosity.
cache : bool (optional, default True)
    Whether to cache nearest-neighbors (before fit) and to store diffusion matrices after mapping (before transform).</p>
<h4 id="topo.tpgraph.diffusion.Diffusor--example">Example</h4>
<p>import numpy as np
from sklearn.datasets import load_digits
from scipy.sparse import csr_matrix
from topo.tpgraph.diffusion import Diffusor</p>
<p>digits = load_digits()
data = csr_matrix(digits)</p>
<p>diff = Diffusor().fit(data)</p>
<p>msdiffmap = diff.transform(data)</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="topo.tpgraph.diffusion.Diffusor.fit" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents ">

      <p>Fits an adaptive anisotropic diffusion kernel to the data.</p>
<h5 id="topo.tpgraph.diffusion.Diffusor.fit--parameters">Parameters</h5>
<p>X :
    input data. Takes in numpy arrays and scipy csr sparse matrices.
Use with sparse data for top performance. You can adjust a series of
parameters that can make the process faster and more informational depending
on your dataset.</p>
<h5 id="topo.tpgraph.diffusion.Diffusor.fit--returns">Returns</h5>
<pre><code>Diffusor object with kernel Diffusor.K and the transition potencial Diffusor.T .
</code></pre>

        <details class="quote">
          <summary>Source code in <code>topo/tpgraph/diffusion.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits an adaptive anisotropic diffusion kernel to the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X :</span>
<span class="sd">        input data. Takes in numpy arrays and scipy csr sparse matrices.</span>
<span class="sd">    Use with sparse data for top performance. You can adjust a series of</span>
<span class="sd">    parameters that can make the process faster and more informational depending</span>
<span class="sd">    on your dataset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Diffusor object with kernel Diffusor.K and the transition potencial Diffusor.T .</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">X</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_use</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="s1">&#39;simple_adaptive&#39;</span><span class="p">,</span> <span class="s1">&#39;decay&#39;</span><span class="p">,</span> <span class="s1">&#39;decay_adaptive&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Kernel must be either </span><span class="se">\&#39;</span><span class="s1">simple</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">simple_adaptive</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">decay</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">decay_adaptive</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span> 
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">:</span>
        <span class="c1"># Construct an approximate k-nearest-neighbors graph</span>
        <span class="n">anbrs</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">NMSlibTransformer</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span>
                                      <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span>
                                      <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span>
                                      <span class="n">method</span><span class="o">=</span><span class="s1">&#39;hnsw&#39;</span><span class="p">,</span>
                                      <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                                      <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                      <span class="n">efC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efC</span><span class="p">,</span>
                                      <span class="n">efS</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efS</span><span class="p">,</span>
                                      <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">knn</span> <span class="o">=</span> <span class="n">anbrs</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># X, y specific stds: Normalize by the distance of median nearest neighbor to account for neighborhood size.</span>
        <span class="n">median_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">adap_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adap_sd</span><span class="p">)):</span>
            <span class="n">adap_sd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">knn</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">knn</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">knn</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])[</span>
                <span class="n">median_k</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;lp&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Generalized Lp distances are available only with `ann` set to True.&#39;</span><span class="p">)</span>

        <span class="c1"># Construct a k-nearest-neighbors graph</span>
        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">data</span><span class="p">)</span>
        <span class="n">knn</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">)</span>
        <span class="c1"># X, y specific stds: Normalize by the distance of median nearest neighbor to account for neighborhood size.</span>
        <span class="n">median_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">adap_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adap_sd</span><span class="p">)):</span>
            <span class="n">adap_sd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">knn</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">knn</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">knn</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])[</span>
                <span class="n">median_k</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="p">]</span>

    <span class="c1"># Distance metrics</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">knn</span><span class="p">)</span>  <span class="c1"># k-nearest-neighbor distances</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dists</span> <span class="o">=</span> <span class="n">knn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adap_sd</span> <span class="o">=</span> <span class="n">adap_sd</span>

    <span class="c1"># Neighborhood graph expansion</span>
    <span class="c1"># define decay as sample&#39;s pseudomedian k-nearest-neighbor</span>
    <span class="n">pm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">adap_sd</span><span class="p">,</span> <span class="p">(</span><span class="n">adap_sd</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">adap_sd</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">))</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">pm</span>
    <span class="c1"># adaptive neighborhood size</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_use</span> <span class="o">==</span> <span class="s1">&#39;simple_adaptive&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_use</span> <span class="o">==</span> <span class="s1">&#39;decay_adaptive&#39;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">-</span> <span class="n">pm</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
        <span class="c1"># increase neighbor search:</span>
        <span class="n">anbrs_new</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">NMSlibTransformer</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">new_k</span><span class="p">,</span>
                                          <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span>
                                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;hnsw&#39;</span><span class="p">,</span>
                                          <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                                          <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span>
                                          <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                          <span class="n">efC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efC</span><span class="p">,</span>
                                          <span class="n">efS</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efS</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">knn_new</span> <span class="o">=</span> <span class="n">anbrs_new</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">x_new</span><span class="p">,</span> <span class="n">y_new</span><span class="p">,</span> <span class="n">dists_new</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">knn_new</span><span class="p">)</span>

        <span class="c1"># adaptive neighborhood size</span>
        <span class="n">adap_nbr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adap_nbr</span><span class="p">)):</span>
            <span class="n">adap_k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pm</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">adap_nbr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">knn_new</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">knn_new</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">knn_new</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])[</span>
                <span class="n">adap_k</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dists_new</span> <span class="o">=</span> <span class="n">knn_new</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adap_nbr_sd</span> <span class="o">=</span> <span class="n">adap_nbr</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_use</span> <span class="o">==</span> <span class="s1">&#39;simple&#39;</span><span class="p">:</span>
        <span class="c1"># X, y specific stds</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span> <span class="o">/</span> <span class="p">(</span><span class="n">adap_sd</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>  <span class="c1"># Normalize by the distance of median nearest neighbor</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dists</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_use</span> <span class="o">==</span> <span class="s1">&#39;simple_adaptive&#39;</span><span class="p">:</span>
        <span class="c1"># X, y specific stds</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">dists_new</span> <span class="o">/</span> <span class="p">(</span><span class="n">adap_nbr</span><span class="p">[</span><span class="n">x_new</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>  <span class="c1"># Normalize by normalized contribution to neighborhood size.</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dists</span><span class="p">),</span> <span class="p">(</span><span class="n">x_new</span><span class="p">,</span> <span class="n">y_new</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_use</span> <span class="o">==</span> <span class="s1">&#39;decay&#39;</span><span class="p">:</span>
        <span class="c1"># X, y specific stds</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">(</span><span class="n">dists</span> <span class="o">/</span> <span class="p">(</span><span class="n">adap_sd</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">))</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">-</span> <span class="n">pm</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">/</span> <span class="n">pm</span><span class="p">[</span><span class="n">x</span><span class="p">]))</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dists</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_use</span> <span class="o">==</span> <span class="s1">&#39;decay_adaptive&#39;</span><span class="p">:</span>
        <span class="c1"># X, y specific stds</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">(</span><span class="n">dists_new</span> <span class="o">/</span> <span class="p">(</span><span class="n">adap_nbr</span><span class="p">[</span><span class="n">x_new</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">))</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">(((</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">-</span> <span class="n">pm</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span> <span class="o">-</span> <span class="n">pm</span><span class="p">[</span><span class="n">x_new</span><span class="p">])</span> <span class="o">/</span> <span class="n">pm</span><span class="p">[</span><span class="n">x_new</span><span class="p">]))</span>  <span class="c1"># Normalize by normalized contribution to neighborhood size.</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dists</span><span class="p">),</span> <span class="p">(</span><span class="n">x_new</span><span class="p">,</span> <span class="n">y_new</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>

    <span class="c1"># Kernel construction</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span> <span class="o">+</span> <span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">kernel</span>

    <span class="c1"># handle nan, zeros</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># Diffusion through Markov chain</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># L_alpha</span>
        <span class="n">D</span><span class="p">[</span><span class="n">D</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">D</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))),</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">D</span><span class="p">[</span><span class="n">D</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">D</span><span class="p">[</span><span class="n">D</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Setting the diffusion operator</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))),</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))),</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>

    <span class="c1"># Guarantee symmetry</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Diffusion time = </span><span class="si">%f</span><span class="s1"> (sec), per sample=</span><span class="si">%f</span><span class="s1"> (sec), per sample adjusted for thread number=</span><span class="si">%f</span><span class="s1"> (sec)&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>


    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="topo.tpgraph.diffusion.Diffusor.ind_dist_grad" class="doc doc-heading">
<code class="highlight language-python"><span class="n">ind_dist_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents ">

      <p>Utility function to get indices, distances and gradients from a multiscale diffusion map.</p>
<h5 id="topo.tpgraph.diffusion.Diffusor.ind_dist_grad--parameters">Parameters</h5>
<p>data :
    Input data matrix (numpy array, pandas df, csr_matrix).</p>
<p>!!! n_components "int (optional, default None)"
    Numper of components to map to prior to learning.</p>
<h5 id="topo.tpgraph.diffusion.Diffusor.ind_dist_grad--returns">Returns</h5>
<p>A tuple containing neighborhood indices, distances, gradient and a knn graph.</p>

        <details class="quote">
          <summary>Source code in <code>topo/tpgraph/diffusion.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">ind_dist_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function to get indices, distances and gradients from a multiscale diffusion map.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data :</span>
<span class="sd">        Input data matrix (numpy array, pandas df, csr_matrix).</span>

<span class="sd">    n_components: int (optional, default None)</span>
<span class="sd">        Numper of components to map to prior to learning.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A tuple containing neighborhood indices, distances, gradient and a knn graph.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># Fit an optimal number of components based on the eigengap</span>
    <span class="c1"># Use user&#39;s  or default initial guess</span>
    <span class="n">multiplier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">//</span> <span class="mf">10e4</span>
    <span class="c1"># initial eigen value decomposition</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">D</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>
    <span class="c1"># Normalize by the first diffusion component</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vals</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigengap</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1">#expand eigendecomposition</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">*</span> <span class="n">multiplier</span>
        <span class="k">while</span> <span class="n">residual</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigengap not found for determined number of components. Expanding eigendecomposition to &#39;</span>
                  <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;components.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
                <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">D</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>
            <span class="c1"># Normalize by the first diffusion component</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">+</span> <span class="mi">15</span>
            <span class="c1"># adapted eigen value decomposition</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
                <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">D</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>
            <span class="c1"># Normalize by the first diffusion component</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>


    <span class="c1"># Create the results dictionary</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;EigenVectors&#39;</span><span class="p">:</span> <span class="n">V</span><span class="p">,</span> <span class="s1">&#39;EigenValues&#39;</span><span class="p">:</span> <span class="n">D</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;EigenVectors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;EigenVectors&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">issparse</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;EigenValues&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;EigenValues&#39;</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;EigenValues&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;EigenValues&quot;</span><span class="p">])</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;MultiscaleComponents&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled_eigs</span> <span class="o">=</span> <span class="n">multiscale</span><span class="o">.</span><span class="n">multiscale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">,</span>
                                                                                        <span class="n">n_eigs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_eigs</span><span class="p">,</span>
                                                                                        <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>


    <span class="n">anbrs</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">NMSlibTransformer</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span>
                                  <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span>
                                  <span class="n">method</span><span class="o">=</span><span class="s1">&#39;hnsw&#39;</span><span class="p">,</span>
                                  <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                                  <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                  <span class="n">efC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efC</span><span class="p">,</span>
                                  <span class="n">efS</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efS</span><span class="p">,</span>
                                  <span class="n">dense</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span>
                                  <span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;MultiscaleComponents&#39;</span><span class="p">])</span>

    <span class="n">ind</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">anbrs</span><span class="o">.</span><span class="n">ind_dist_grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;MultiscaleComponents&#39;</span><span class="p">])</span>

    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Diffusion time = </span><span class="si">%f</span><span class="s1"> (sec), per sample=</span><span class="si">%f</span><span class="s1"> (sec), per sample adjusted for thread number=</span><span class="si">%f</span><span class="s1"> (sec)&#39;</span> <span class="o">%</span>
          <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_spectrum</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_plot</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ind</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">graph</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="topo.tpgraph.diffusion.Diffusor.rescale" class="doc doc-heading">
<code class="highlight language-python"><span class="n">rescale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_eigs</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents ">

      <p>Re-scale the multiscale procedure to a new number of components.</p>
<h5 id="topo.tpgraph.diffusion.Diffusor.rescale--parameters">Parameters</h5>
<p>self : Diffusor object.</p>
<p>n_eigs : int. Number of diffusion components to multiscale.</p>
<h5 id="topo.tpgraph.diffusion.Diffusor.rescale--returns">Returns</h5>
<p>np.ndarray containing the new multiscaled basis.</p>

        <details class="quote">
          <summary>Source code in <code>topo/tpgraph/diffusion.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">rescale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_eigs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Re-scale the multiscale procedure to a new number of components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self : Diffusor object.</span>

<span class="sd">    n_eigs : int. Number of diffusion components to multiscale.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    np.ndarray containing the new multiscaled basis.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n_eigs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_eigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>

    <span class="n">mms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled_eigs</span> <span class="o">=</span> <span class="n">multiscale</span><span class="o">.</span><span class="n">multiscale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">,</span>
                                                            <span class="n">n_eigs</span><span class="o">=</span><span class="n">n_eigs</span><span class="p">,</span>
                                                            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;MultiscaleComponents&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mms</span>
    <span class="k">return</span> <span class="n">mms</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="topo.tpgraph.diffusion.Diffusor.spectrum_plot" class="doc doc-heading">
<code class="highlight language-python"><span class="n">spectrum_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bla</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents ">

      <p>Plot the decay spectra.</p>
<h5 id="topo.tpgraph.diffusion.Diffusor.spectrum_plot--parameters">Parameters</h5>
<p>self : Diffusor object.</p>
<p>bla : Here only for autodoc's sake.</p>
<h5 id="topo.tpgraph.diffusion.Diffusor.spectrum_plot--returns">Returns</h5>
<p>A nice plot of the diffusion spectra.</p>

        <details class="quote">
          <summary>Source code in <code>topo/tpgraph/diffusion.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">spectrum_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bla</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the decay spectra.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self : Diffusor object.</span>

<span class="sd">    bla : Here only for autodoc&#39;s sake.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    A nice plot of the diffusion spectra.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled_eigs</span> <span class="o">=</span> <span class="n">multiscale</span><span class="o">.</span><span class="n">multiscale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">,</span>
                                             <span class="n">n_eigs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_eigs</span><span class="p">,</span>
                                             <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

    <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Spectrum decay and </span><span class="se">\&#39;</span><span class="s1">knee</span><span class="se">\&#39;</span><span class="s1"> (</span><span class="si">%i</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">knee</span><span class="p">))</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Eigenvalues&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Eigenvectors&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">knee</span><span class="p">,</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Knee&#39;</span>
    <span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>

    <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Curve analysis&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">x_normalized</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">y_normalized</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;normalized&quot;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">x_difference</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">y_difference</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;differential&quot;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">x_normalized</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">x_normalized</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">y_difference</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">y_normalized</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">ax2</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="o">.</span><span class="n">norm_knee</span><span class="p">,</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Knee&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">plt</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="topo.tpgraph.diffusion.Diffusor.transform" class="doc doc-heading">
<code class="highlight language-python"><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents ">

      <p>Fits the renormalized Laplacian approximating the Laplace Beltrami-Operator
 in a discrete eigendecomposition. Then multiscales the resulting components.
 Parameters</p>
<hr />
<p>X :
     input data. Takes in numpy arrays and scipy csr sparse matrices.
 Use with sparse data for top performance. You can adjust a series of
 parameters that can make the process faster and more informational depending
 on your dataset.</p>
<p>Returns</p>
<hr />
<p><code>Diffusor.res['MultiscaleComponents']]</code></p>

        <details class="quote">
          <summary>Source code in <code>topo/tpgraph/diffusion.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits the renormalized Laplacian approximating the Laplace Beltrami-Operator</span>
<span class="sd">    in a discrete eigendecomposition. Then multiscales the resulting components.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X :</span>
<span class="sd">        input data. Takes in numpy arrays and scipy csr sparse matrices.</span>
<span class="sd">    Use with sparse data for top performance. You can adjust a series of</span>
<span class="sd">    parameters that can make the process faster and more informational depending</span>
<span class="sd">    on your dataset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">   ``Diffusor.res[&#39;MultiscaleComponents&#39;]]``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># Fit an optimal number of components based on the eigengap</span>
    <span class="c1"># Use user&#39;s  or default initial guess</span>
    <span class="c1"># initial eigen value decomposition</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">//</span> <span class="mi">10</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">//</span> <span class="mi">10</span><span class="p">))</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">D</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>
    <span class="c1"># Normalize by the first diffusion component</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vals</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigengap</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1">#expand eigendecomposition</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">+</span> <span class="mi">30</span>
        <span class="k">while</span> <span class="n">residual</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigengap not found for determined number of components. Expanding eigendecomposition to &#39;</span>
                  <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;components.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
                <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">//</span> <span class="mi">10</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">//</span> <span class="mi">10</span><span class="p">))</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">D</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>
            <span class="c1"># Normalize by the first diffusion component</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vals</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">target</span> <span class="o">*</span> <span class="mf">1.6</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span>
        <span class="c1"># adapted eigen value decomposition</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
           <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">D</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">D</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Create the results dictionary</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;EigenVectors&#39;</span><span class="p">:</span> <span class="n">V</span><span class="p">,</span> <span class="s1">&#39;EigenValues&#39;</span><span class="p">:</span> <span class="n">D</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;EigenVectors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;EigenVectors&#39;</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;EigenValues&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;EigenValues&quot;</span><span class="p">])</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;MultiscaleComponents&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">kn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled_eigs</span> <span class="o">=</span> <span class="n">multiscale</span><span class="o">.</span><span class="n">multiscale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Multiscale decomposition time = </span><span class="si">%f</span><span class="s1"> (sec), per sample=</span><span class="si">%f</span><span class="s1"> (sec), per sample adjusted for thread number=</span><span class="si">%f</span><span class="s1"> (sec)&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_spectrum</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_plot</span><span class="p">()</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;MultiscaleComponents&#39;</span><span class="p">]</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../topograph/" class="btn btn-neutral" title="The TopOGraph model"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../topograph/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
