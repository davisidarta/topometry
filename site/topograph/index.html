<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>The TopOGraph model - TopOMetry Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "The TopOGraph model";
    var mkdocs_page_input_path = "topograph.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> TopOMetry Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Welcome!</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../installation/">Installation</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../quickstart/">Quick-start</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../TopOMetry_Intro_pbmc_10k/">Single-cell analysis</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">The TopOGraph model</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#topo.models.TopOGraph">TopOGraph</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#topo.models.TopOGraph.fit">fit()</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#topo.models.TopOGraph.fit--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#topo.models.TopOGraph.fit--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#topo.models.TopOGraph.MAP">MAP()</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#topo.models.TopOGraph.MAP--parameters">Parameters</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#topo.models.TopOGraph.MDE">MDE()</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#topo.models.TopOGraph.MDE--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#topo.models.TopOGraph.MDE--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#topo.models.TopOGraph.spectral_layout">spectral_layout()</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#topo.models.TopOGraph.spectral_layout--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#topo.models.TopOGraph.spectral_layout--returns">Returns</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#topo.models.TopOGraph.transform">transform()</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#topo.models.TopOGraph.transform--parameters">Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#topo.models.TopOGraph.transform--returns">Returns</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../diffusor/">Diffusion harmonics</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">TopOMetry Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>The TopOGraph model</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="documentation-for-topograph">Documentation for <code>TopOGraph</code></h1>


  <div class="doc doc-object doc-class">



<h2 id="topo.models.TopOGraph" class="doc doc-heading">
        <code>topo.models.TopOGraph</code>



</h2>

    <div class="doc doc-contents first">

      <p>Convenient TopOMetry class for building, clustering and visualizing n-order topological graphs.</p>
<p>From data, builds a topologically-oriented basis with  optimized diffusion maps or a continuous k-nearest-neighbors
 Laplacian Eigenmap, and from this basis learns a topological graph (using a new diffusion process or a continuous 
 kNN kernel). This model approximates the Laplace-Beltrami Operator multiple ways by different ways, depending on
 the user setup. The topological graph can then be visualized in two or three dimensions with Minimum Distortion
 Embeddings, which also allows for flexible setup and domain-adaptation. Alternatively, users can explore multiple
 classes for graph layout optimization in <code>topo.layout</code>. </p>
<p>Parameters</p>
<hr />
<p>base_knn : int (optional, default 10).
     Number of k-nearest-neighbors to compute the <code>Diffusor</code> base operator on.
     The adaptive kernel will normalize distances by each cell distance of its median neighbor. Nonetheless,
     this hyperparameter remains as an user input regarding the minimal sample neighborhood resolution that drives
     the computation of the diffusion metrics. For practical purposes, the minimum amount of samples one would
     expect to constitute a neighborhood of its own. Increasing <code>k</code> can generate more globally-comprehensive metrics
     and maps, to a certain extend, however at the expense of fine-grained resolution. More generally,
      consider this a calculus discretization threshold.</p>
<p>graph_knn : int (optional, default 10).
     Number of k-nearest-neighbors to compute the graph operator on.
     The adaptive kernel will normalize distances by each cell distance of its median neighbor. Nonetheless, this
     hyperparameter remains as an user input regarding the minimal sample neighborhood resolution that drives the 
     computation of the diffusion metrics. For practical purposes, the minimum amount of samples one would expect
     to constitute a neighborhood of its own. Increasing <code>k</code> can generate more globally-comprehensive metrics 
     and maps, to a certain extend,
     however at the expense of fine-grained resolution. More generally, consider this a calculus
     discretization threshold.</p>
<p>n_eigs : int (optional, default 50).
     Number of components to compute. This number can be iterated to get different views
     from data at distinct spectral resolutions. If <code>basis</code> is set to <code>diffusion</code>, this is the number of 
     computed diffusion components. If <code>basis</code> is set to <code>continuous</code>, this is the number of computed eigenvectors
     of the Laplacian Eigenmaps from the continuous affinity matrix.</p>
<p>basis : 'diffusion' or 'continuous' (optional, default 'diffusion').
     Which topological basis to build from data. If <code>diffusion</code>, performs an optimized, anisotropic, adaptive
     diffusion mapping (default). If <code>continuous</code>, computes affinities from continuous k-nearest-neighbors, and a 
     topological basis from the Laplacian Eigenmaps of such metric.</p>
<p>graph : 'diff' or 'cknn' (optional, default 'diff').
     Which topological graph to learn from the built basis. If 'diff', uses a second-order diffusion process to learn
     similarities and transition probabilities. If 'cknn', uses the continuous k-nearest-neighbors algorithms. Both
     algorithms learn graph-oriented topological metrics from the learned basis.</p>
<p>ann : bool (optional, default True).
     Whether to use approximate nearest neighbors for graph construction. If <code>False</code>, uses <code>sklearn</code> default implementation.</p>
<p>base_metric : str (optional, default 'cosine').
     Distance metrics for building a approximate kNN graphs. Defaults to 'cosine'. Users are encouraged to explore
     different metrics, such as 'cosine' and 'jaccard'. The 'hamming' and 'jaccard' distances are also available
     for string vectors. Accepted metrics include NMSLib metrics and sklearn metrics. Some examples are:</p>
<pre><code> -'sqeuclidean'

 -'euclidean'

 -'l1'

 -'lp' - requires setting the parameter ``p``

 -'cosine'

 -'angular'

 -'negdotprod'

 -'levenshtein'

 -'hamming'

 -'jaccard'

 -'jansen-shan'
</code></pre>
<p>graph_metric : str (optional, default 'cosine').
     Exactly the same as base_matric, but used for building the topological graph.</p>
<p>p : int or float (optional, default 11/16 )
     P for the Lp metric, when <code>metric='lp'</code>.  Can be fractional. The default 11/16 approximates
     an astroid norm with some computational efficiency (2^n bases are less painstakinly slow to compute).</p>
<p>transitions : bool (optional, default False)
     Whether to estimate the diffusion transitions graph. If <code>True</code>, maps a basis encoding neighborhood
      transitions probability during eigendecomposition. If 'False' (default), maps the diffusion kernel.</p>
<p>alpha : int or float (optional, default 1)
     Alpha in the diffusion maps literature. Controls how much the results are biased by data distribution.
         Defaults to 1, which is suitable for normalized data.</p>
<p>kernel_use : str (optional, default 'decay_adaptive')
     Which type of kernel to use in the diffusion approach. There are four implemented, considering the adaptive 
     decay and the neighborhood expansion, written as 'simple', 'decay', 'simple_adaptive' and 'decay_adaptive'.
     The first, 'simple', is a locally-adaptive kernel similar to that proposed by Nadler et al.
     (https://doi.org/10.1016/j.acha.2005.07.004) and implemented in Setty et al. 
     (https://doi.org/10.1038/s41587-019-0068-4).
     The 'decay' option applies an adaptive decay rate, but no neighborhood expansion.
     Those, followed by '_adaptive', apply the neighborhood expansion process. The default and recommended is 'decay_adaptive'.
     The neighborhood expansion can impact runtime, although this is not usually expressive for datasets under 10e6 samples.</p>
<p>transitions : bool (optional, default False).
     Whether to decompose the transition graph when fitting the diffusion basis.
 n_jobs : int.
     Number of threads to use in calculations. Defaults to all but one.
 verbose : bool (optional, default False).
     Controls verbosity.
 cache : bool (optional, default True).
     Whether to cache nearest-neighbors (before fit) and to store diffusion matrices after mapping (before transform).</p>




  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="topo.models.TopOGraph.fit" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents ">

      <p>Learn topological distances with diffusion harmonics and continuous metrics. Computes affinity operators
that approximate the Laplace-Beltrami operator</p>
<h5 id="topo.models.TopOGraph.fit--parameters">Parameters</h5>
<p>data :
    High-dimensional data matrix. Currently, supports only data from similar type (i.e. all bool, all float)</p>
<h5 id="topo.models.TopOGraph.fit--returns">Returns</h5>
<p>TopoGraph instance with several slots, populated as per user settings.
If <code>basis=diffusion</code>, populates <code>TopoGraph.MSDiffMap</code> with a multiscale diffusion mapping of data, and
        <code>TopoGraph.DiffBasis</code> with a fitted <code>topo.tpgraph.diff.Diffusor()</code> class containing diffusion metrics
        and transition probabilities, respectively stored in TopoGraph.DiffBasis.K and TopoGraph.DiffBasis.T</p>
<p>If <code>basis=continuous</code>, populates <code>TopoGraph.CLapMap</code> with a continous Laplacian Eigenmapping of data, and
        <code>TopoGraph.ContBasis</code> with a continuous-k-nearest-neighbors model, containing continuous metrics and
        adjacency, respectively stored in <code>TopoGraph.ContBasis.K</code> and <code>TopoGraph.ContBasis.A</code>.</p>

        <details class="quote">
          <summary>Source code in <code>topo/models.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Learn topological distances with diffusion harmonics and continuous metrics. Computes affinity operators</span>
<span class="sd">    that approximate the Laplace-Beltrami operator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data :</span>
<span class="sd">        High-dimensional data matrix. Currently, supports only data from similar type (i.e. all bool, all float)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    TopoGraph instance with several slots, populated as per user settings.</span>
<span class="sd">    If `basis=diffusion`, populates `TopoGraph.MSDiffMap` with a multiscale diffusion mapping of data, and</span>
<span class="sd">            `TopoGraph.DiffBasis` with a fitted `topo.tpgraph.diff.Diffusor()` class containing diffusion metrics</span>
<span class="sd">            and transition probabilities, respectively stored in TopoGraph.DiffBasis.K and TopoGraph.DiffBasis.T</span>

<span class="sd">    If `basis=continuous`, populates `TopoGraph.CLapMap` with a continous Laplacian Eigenmapping of data, and</span>
<span class="sd">            `TopoGraph.ContBasis` with a continuous-k-nearest-neighbors model, containing continuous metrics and</span>
<span class="sd">            adjacency, respectively stored in `TopoGraph.ContBasis.K` and `TopoGraph.ContBasis.A`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Building topological basis...&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;diffusion&#39;</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DiffBasis</span> <span class="o">=</span> <span class="n">Diffusor</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_eigs</span><span class="p">,</span>
                                  <span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_knn</span><span class="p">,</span>
                                  <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                  <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                                  <span class="n">ann</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">,</span>
                                  <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_metric</span><span class="p">,</span>
                                  <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span>
                                  <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                  <span class="n">efC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efC</span><span class="p">,</span>
                                  <span class="n">efS</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efS</span><span class="p">,</span>
                                  <span class="n">kernel_use</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_use</span><span class="p">,</span>
                                  <span class="n">norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span>
                                  <span class="n">transitions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">,</span>
                                  <span class="n">eigengap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eigengap</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                                  <span class="n">plot_spectrum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_spectrum</span><span class="p">,</span>
                                  <span class="n">cache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_base</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MSDiffMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DiffBasis</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Topological basis fitted with diffusion mappings in </span><span class="si">%f</span><span class="s1"> (sec)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>

    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ContBasis</span> <span class="o">=</span> <span class="n">cknn_graph</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                    <span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_knn</span><span class="p">,</span>
                                    <span class="n">delta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span>
                                    <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_metric</span><span class="p">,</span>
                                    <span class="n">t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span>
                                    <span class="n">include_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">is_sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">return_instance</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">CLapMap</span> <span class="o">=</span> <span class="n">spt</span><span class="o">.</span><span class="n">LapEigenmap</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ContBasis</span><span class="o">.</span><span class="n">K</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_eigs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">expansion</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CLapMap</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CLapMap</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CLapMap</span> <span class="o">*</span> <span class="n">expansion</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
            <span class="n">scale</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ContBasis</span><span class="o">.</span><span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_eigs</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Topological basis fitted with continuous mappings in </span><span class="si">%f</span><span class="s1"> (sec)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>

    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="topo.models.TopOGraph.MAP" class="doc doc-heading">
<code class="highlight language-python"><span class="n">MAP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">initial_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_epochs</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="n">metric_kwds</span><span class="o">=</span><span class="p">{},</span> <span class="n">output_metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="n">output_metric_kwds</span><span class="o">=</span><span class="p">{},</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">negative_sample_rate</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s1">&#39;spectral&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">euclidean_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">njobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">densmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">densmap_kwds</span><span class="o">=</span><span class="p">{},</span> <span class="n">output_dens</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents ">

      <p>""</p>
<p>Manifold Approximation and Projection, as proposed by Leland McInnes with an uniform distribution assumption in
the seminal <a href="https://umap-learn.readthedocs.io/en/latest/index.html">UMAP algorithm</a>. Perform a fuzzy simplicial set embedding, using a
specified initialisation method and then minimizing the fuzzy set cross entropy between the 1-skeletons of the high
and low dimensional fuzzy simplicial sets. The fuzzy simplicial set embedding was proposed and implemented by
Leland McInnes in UMAP (see <code>umap-learn &lt;https://github.com/lmcinnes/umap&gt;</code>). Here we're using it only for the
projection (layout optimization) by minimizing the cross-entropy between a phenotypic map (i.e. data, TopOMetry latent mappings)
and its graph topological representation.</p>
<h5 id="topo.models.TopOGraph.MAP--parameters">Parameters</h5>
<p>!!! data "array of shape (n_samples, n_features)"
    The source data to be embedded by UMAP.
!!! graph "sparse matrix"
    The 1-skeleton of the high dimensional fuzzy simplicial set as
    represented by a graph for which we require a sparse matrix for the
    (weighted) adjacency matrix.
!!! n_components "int"
    The dimensionality of the euclidean space into which to embed the data.
!!! initial_alpha "float"
    Initial learning rate for the SGD.
!!! a "float"
    Parameter of differentiable approximation of right adjoint functor
!!! b "float"
    Parameter of differentiable approximation of right adjoint functor
!!! gamma "float"
    Weight to apply to negative samples.
!!! negative_sample_rate "int (optional, default 5)"
    The number of negative samples to select per positive sample
    in the optimization process. Increasing this value will result
    in greater repulsive force being applied, greater optimization
    cost, but slightly more accuracy.
!!! n_epochs "int (optional, default 0)"
    The number of training epochs to be used in optimizing the
    low dimensional embedding. Larger values result in more accurate
    embeddings. If 0 is specified a value will be selected based on
    the size of the input dataset (200 for large datasets, 500 for small).
!!! init "string"
    How to initialize the low dimensional embedding. Options are:
        * 'spectral': use a spectral embedding of the fuzzy 1-skeleton
        * 'random': assign initial embedding positions at random.
        * A numpy array of initial embedding positions.
!!! random_state "numpy RandomState or equivalent"
    A state capable being used as a numpy random state.
!!! metric "string or callable"
    The metric used to measure distance in high dimensional space; used if
    multiple connected components need to be layed out.
!!! metric_kwds "dict"
    Key word arguments to be passed to the metric function; used if
    multiple connected components need to be layed out.
!!! densmap "bool"
    Whether to use the density-augmented objective function to optimize
    the embedding according to the densMAP algorithm.
!!! densmap_kwds "dict"
    Key word arguments to be used by the densMAP optimization.
!!! output_dens "bool"
    Whether to output local radii in the original data and the embedding.
!!! output_metric "function"
    Function returning the distance between two points in embedding space and
    the gradient of the distance wrt the first argument.
!!! output_metric_kwds "dict"
    Key word arguments to be passed to the output_metric function.
!!! euclidean_output "bool"
    Whether to use the faster code specialised for euclidean output metrics
!!! parallel "bool (optional, default False)"
    Whether to run the computation using numba parallel.
    Running in parallel is non-deterministic, and is not used
    if a random seed has been set, to ensure reproducibility.
!!! return_init "bool , (optional, default False)"
    Whether to also return the multicomponent spectral initialization.
!!! verbose "bool (optional, default False)"
    Whether to report information on the current progress of the algorithm.
Returns</p>
<hr />
<p>!!! embedding "array of shape (n_samples, n_components)"
    The optimized of <code>graph</code> into an <code>n_components</code> dimensional
    euclidean space.
!!! aux_data "dict"
    Auxiliary dictionary output returned with the embedding.
    <code>aux_data['Y_init']</code>: array of shape (n_samples, n_components)
        The spectral initialization of <code>graph</code> into an <code>n_components</code> dimensional
        euclidean space.</p>
<pre><code>When densMAP extension is turned on, this dictionary includes local radii in the original
data (``aux_data['rad_orig']``) and in the embedding (``aux_data['rad_emb']``).
</code></pre>

        <details class="quote">
          <summary>Source code in <code>topo/models.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">MAP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">min_dist</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
        <span class="n">spread</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
        <span class="n">initial_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">n_epochs</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span>
        <span class="n">metric_kwds</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">output_metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
        <span class="n">output_metric_kwds</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">gamma</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
        <span class="n">negative_sample_rate</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">init</span><span class="o">=</span><span class="s1">&#39;spectral&#39;</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">euclidean_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">njobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">densmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">densmap_kwds</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">output_dens</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;&quot;</span>

<span class="sd">    Manifold Approximation and Projection, as proposed by Leland McInnes with an uniform distribution assumption in</span>
<span class="sd">    the seminal [UMAP algorithm](https://umap-learn.readthedocs.io/en/latest/index.html). Perform a fuzzy simplicial set embedding, using a</span>
<span class="sd">    specified initialisation method and then minimizing the fuzzy set cross entropy between the 1-skeletons of the high</span>
<span class="sd">    and low dimensional fuzzy simplicial sets. The fuzzy simplicial set embedding was proposed and implemented by</span>
<span class="sd">    Leland McInnes in UMAP (see `umap-learn &lt;https://github.com/lmcinnes/umap&gt;`). Here we&#39;re using it only for the</span>
<span class="sd">    projection (layout optimization) by minimizing the cross-entropy between a phenotypic map (i.e. data, TopOMetry latent mappings)</span>
<span class="sd">    and its graph topological representation.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: array of shape (n_samples, n_features)</span>
<span class="sd">        The source data to be embedded by UMAP.</span>
<span class="sd">    graph: sparse matrix</span>
<span class="sd">        The 1-skeleton of the high dimensional fuzzy simplicial set as</span>
<span class="sd">        represented by a graph for which we require a sparse matrix for the</span>
<span class="sd">        (weighted) adjacency matrix.</span>
<span class="sd">    n_components: int</span>
<span class="sd">        The dimensionality of the euclidean space into which to embed the data.</span>
<span class="sd">    initial_alpha: float</span>
<span class="sd">        Initial learning rate for the SGD.</span>
<span class="sd">    a: float</span>
<span class="sd">        Parameter of differentiable approximation of right adjoint functor</span>
<span class="sd">    b: float</span>
<span class="sd">        Parameter of differentiable approximation of right adjoint functor</span>
<span class="sd">    gamma: float</span>
<span class="sd">        Weight to apply to negative samples.</span>
<span class="sd">    negative_sample_rate: int (optional, default 5)</span>
<span class="sd">        The number of negative samples to select per positive sample</span>
<span class="sd">        in the optimization process. Increasing this value will result</span>
<span class="sd">        in greater repulsive force being applied, greater optimization</span>
<span class="sd">        cost, but slightly more accuracy.</span>
<span class="sd">    n_epochs: int (optional, default 0)</span>
<span class="sd">        The number of training epochs to be used in optimizing the</span>
<span class="sd">        low dimensional embedding. Larger values result in more accurate</span>
<span class="sd">        embeddings. If 0 is specified a value will be selected based on</span>
<span class="sd">        the size of the input dataset (200 for large datasets, 500 for small).</span>
<span class="sd">    init: string</span>
<span class="sd">        How to initialize the low dimensional embedding. Options are:</span>
<span class="sd">            * &#39;spectral&#39;: use a spectral embedding of the fuzzy 1-skeleton</span>
<span class="sd">            * &#39;random&#39;: assign initial embedding positions at random.</span>
<span class="sd">            * A numpy array of initial embedding positions.</span>
<span class="sd">    random_state: numpy RandomState or equivalent</span>
<span class="sd">        A state capable being used as a numpy random state.</span>
<span class="sd">    metric: string or callable</span>
<span class="sd">        The metric used to measure distance in high dimensional space; used if</span>
<span class="sd">        multiple connected components need to be layed out.</span>
<span class="sd">    metric_kwds: dict</span>
<span class="sd">        Key word arguments to be passed to the metric function; used if</span>
<span class="sd">        multiple connected components need to be layed out.</span>
<span class="sd">    densmap: bool</span>
<span class="sd">        Whether to use the density-augmented objective function to optimize</span>
<span class="sd">        the embedding according to the densMAP algorithm.</span>
<span class="sd">    densmap_kwds: dict</span>
<span class="sd">        Key word arguments to be used by the densMAP optimization.</span>
<span class="sd">    output_dens: bool</span>
<span class="sd">        Whether to output local radii in the original data and the embedding.</span>
<span class="sd">    output_metric: function</span>
<span class="sd">        Function returning the distance between two points in embedding space and</span>
<span class="sd">        the gradient of the distance wrt the first argument.</span>
<span class="sd">    output_metric_kwds: dict</span>
<span class="sd">        Key word arguments to be passed to the output_metric function.</span>
<span class="sd">    euclidean_output: bool</span>
<span class="sd">        Whether to use the faster code specialised for euclidean output metrics</span>
<span class="sd">    parallel: bool (optional, default False)</span>
<span class="sd">        Whether to run the computation using numba parallel.</span>
<span class="sd">        Running in parallel is non-deterministic, and is not used</span>
<span class="sd">        if a random seed has been set, to ensure reproducibility.</span>
<span class="sd">    return_init: bool , (optional, default False)</span>
<span class="sd">        Whether to also return the multicomponent spectral initialization.</span>
<span class="sd">    verbose: bool (optional, default False)</span>
<span class="sd">        Whether to report information on the current progress of the algorithm.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    embedding: array of shape (n_samples, n_components)</span>
<span class="sd">        The optimized of ``graph`` into an ``n_components`` dimensional</span>
<span class="sd">        euclidean space.</span>
<span class="sd">    aux_data: dict</span>
<span class="sd">        Auxiliary dictionary output returned with the embedding.</span>
<span class="sd">        ``aux_data[&#39;Y_init&#39;]``: array of shape (n_samples, n_components)</span>
<span class="sd">            The spectral initialization of ``graph`` into an ``n_components`` dimensional</span>
<span class="sd">            euclidean space.</span>

<span class="sd">        When densMAP extension is turned on, this dictionary includes local radii in the original</span>
<span class="sd">        data (``aux_data[&#39;rad_orig&#39;]``) and in the embedding (``aux_data[&#39;rad_emb&#39;]``).</span>


<span class="sd">    &quot;&quot;&quot;</span><span class="s2">&quot;&quot;</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">uni</span><span class="o">.</span><span class="n">fuzzy_embedding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span>
                                  <span class="n">n_components</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
                                  <span class="n">initial_alpha</span><span class="o">=</span><span class="n">initial_alpha</span><span class="p">,</span>
                                  <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span>
                                  <span class="n">spread</span><span class="o">=</span><span class="n">spread</span><span class="p">,</span>
                                  <span class="n">n_epochs</span><span class="o">=</span><span class="n">n_epochs</span><span class="p">,</span>
                                  <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                                  <span class="n">metric_kwds</span><span class="o">=</span><span class="n">metric_kwds</span><span class="p">,</span>
                                  <span class="n">output_metric</span><span class="o">=</span><span class="n">output_metric</span><span class="p">,</span>
                                  <span class="n">output_metric_kwds</span><span class="o">=</span><span class="n">output_metric_kwds</span><span class="p">,</span>
                                  <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span>
                                  <span class="n">negative_sample_rate</span><span class="o">=</span><span class="n">negative_sample_rate</span><span class="p">,</span>
                                  <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
                                  <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                                  <span class="n">euclidean_output</span><span class="o">=</span><span class="n">euclidean_output</span><span class="p">,</span>
                                  <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
                                  <span class="n">njobs</span><span class="o">=</span><span class="n">njobs</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                  <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">densmap</span><span class="o">=</span><span class="n">densmap</span><span class="p">,</span>
                                  <span class="n">densmap_kwds</span><span class="o">=</span><span class="n">densmap_kwds</span><span class="p">,</span>
                                  <span class="n">output_dens</span><span class="o">=</span><span class="n">output_dens</span><span class="p">)</span>

    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fuzzy layout optimization embedding in = </span><span class="si">%f</span><span class="s1"> (sec)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">results</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="topo.models.TopOGraph.MDE" class="doc doc-heading">
<code class="highlight language-python"><span class="n">MDE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;isomorphic&#39;</span><span class="p">,</span> <span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;standardized&#39;</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="n">attractive_penalty</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">pymde</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Log1p</span><span class="s1">&#39;&gt;, repulsive_penalty=&lt;class &#39;</span><span class="n">pymde</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Log</span><span class="s1">&#39;&gt;, loss=&lt;class &#39;</span><span class="n">pymde</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">Absolute</span><span class="s1">&#39;&gt;, repulsive_fraction=None, max_distance=None, device=&#39;</span><span class="n">cpu</span><span class="s1">&#39;, verbose=False)</span></code>


</h3>

    <div class="doc doc-contents ">

      <p>This function constructs an MDE problem for preserving the
structure of original data. This MDE problem is well-suited for
visualization (using <code>dim</code> 2 or 3), but can also be used to
generate features for machine learning tasks (with <code>dim</code> = 10,
50, or 100, for example). It yields embeddings in which similar items
are near each other, and dissimilar items are not near each other.
The original data can either be a data matrix, or a graph.
Data matrices should be torch Tensors, NumPy arrays, or scipy sparse
matrices; graphs should be instances of <code>pymde.Graph</code>.
The MDE problem uses distortion functions derived from weights (i.e.,
penalties).
To obtain an embedding, call the <code>embed</code> method on the returned <code>MDE</code>
object. To plot it, use <code>pymde.plot</code>.</p>
<h5 id="topo.models.TopOGraph.MDE--parameters">Parameters</h5>
<p>data : torch.Tensor, numpy.ndarray, scipy.sparse matrix or pymde.Graph.
    The original data, a data matrix of shape <code>(n_items, n_features)</code> or
    a graph. Neighbors are computed using Euclidean distance if the data is
    a matrix, or the shortest-path metric if the data is a graph.
dim : int.
    The embedding dimension. Use 2 or 3 for visualization.
attractive_penalty : pymde.Function class (or factory).
    Callable that constructs a distortion function, given positive
    weights. Typically one of the classes from <code>pymde.penalties</code>,
    such as <code>pymde.penalties.log1p</code>, <code>pymde.penalties.Huber</code>, or
    <code>pymde.penalties.Quadratic</code>.
repulsive_penalty : pymde.Function class (or factory).
    Callable that constructs a distortion function, given negative
    weights. (If <code>None</code>, only positive weights are used.) For example,
    <code>pymde.penalties.Log</code> or <code>pymde.penalties.InversePower</code>.
constraint : str (optional), default 'standardized'.
    Constraint to use when optimizing the embedding. Options are 'standardized',
    'centered', <code>None</code> or a <code>pymde.constraints.Constraint()</code> function.
n_neighbors : int (optional)
    The number of nearest neighbors to compute for each row (item) of
    <code>data</code>. A sensible value is chosen by default, depending on the
    number of items.
repulsive_fraction : float (optional)
    How many repulsive edges to include, relative to the number
    of attractive edges. <code>1</code> means as many repulsive edges as attractive
    edges. The higher this number, the more uniformly spread out the
    embedding will be. Defaults to <code>0.5</code> for standardized embeddings, and
    <code>1</code> otherwise. (If <code>repulsive_penalty</code> is <code>None</code>, this argument
    is ignored.)
max_distance : float (optional)
    If not None, neighborhoods are restricted to have a radius
    no greater than <code>max_distance</code>.
init : str or np.ndarray (optional, default 'quadratic')
    Initialization strategy; np.ndarray, 'quadratic' or 'random'.
device : str (optional)
    Device for the embedding (eg, 'cpu', 'cuda').
verbose : bool
    If <code>True</code>, print verbose output.</p>
<h5 id="topo.models.TopOGraph.MDE--returns">Returns</h5>
<p>torch.tensor
    A <code>pymde.MDE</code> object, based on the original data.</p>

        <details class="quote">
          <summary>Source code in <code>topo/models.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">MDE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">n_neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;isomorphic&#39;</span><span class="p">,</span>
        <span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;standardized&#39;</span><span class="p">,</span>
        <span class="n">init</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">,</span>
        <span class="n">attractive_penalty</span><span class="o">=</span><span class="n">penalties</span><span class="o">.</span><span class="n">Log1p</span><span class="p">,</span>
        <span class="n">repulsive_penalty</span><span class="o">=</span><span class="n">penalties</span><span class="o">.</span><span class="n">Log</span><span class="p">,</span>
        <span class="n">loss</span><span class="o">=</span><span class="n">losses</span><span class="o">.</span><span class="n">Absolute</span><span class="p">,</span>
        <span class="n">repulsive_fraction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function constructs an MDE problem for preserving the</span>
<span class="sd">    structure of original data. This MDE problem is well-suited for</span>
<span class="sd">    visualization (using ``dim`` 2 or 3), but can also be used to</span>
<span class="sd">    generate features for machine learning tasks (with ``dim`` = 10,</span>
<span class="sd">    50, or 100, for example). It yields embeddings in which similar items</span>
<span class="sd">    are near each other, and dissimilar items are not near each other.</span>
<span class="sd">    The original data can either be a data matrix, or a graph.</span>
<span class="sd">    Data matrices should be torch Tensors, NumPy arrays, or scipy sparse</span>
<span class="sd">    matrices; graphs should be instances of ``pymde.Graph``.</span>
<span class="sd">    The MDE problem uses distortion functions derived from weights (i.e.,</span>
<span class="sd">    penalties).</span>
<span class="sd">    To obtain an embedding, call the ``embed`` method on the returned ``MDE``</span>
<span class="sd">    object. To plot it, use ``pymde.plot``.</span>




<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : torch.Tensor, numpy.ndarray, scipy.sparse matrix or pymde.Graph.</span>
<span class="sd">        The original data, a data matrix of shape ``(n_items, n_features)`` or</span>
<span class="sd">        a graph. Neighbors are computed using Euclidean distance if the data is</span>
<span class="sd">        a matrix, or the shortest-path metric if the data is a graph.</span>
<span class="sd">    dim : int.</span>
<span class="sd">        The embedding dimension. Use 2 or 3 for visualization.</span>
<span class="sd">    attractive_penalty : pymde.Function class (or factory).</span>
<span class="sd">        Callable that constructs a distortion function, given positive</span>
<span class="sd">        weights. Typically one of the classes from ``pymde.penalties``,</span>
<span class="sd">        such as ``pymde.penalties.log1p``, ``pymde.penalties.Huber``, or</span>
<span class="sd">        ``pymde.penalties.Quadratic``.</span>
<span class="sd">    repulsive_penalty : pymde.Function class (or factory).</span>
<span class="sd">        Callable that constructs a distortion function, given negative</span>
<span class="sd">        weights. (If ``None``, only positive weights are used.) For example,</span>
<span class="sd">        ``pymde.penalties.Log`` or ``pymde.penalties.InversePower``.</span>
<span class="sd">    constraint : str (optional), default &#39;standardized&#39;.</span>
<span class="sd">        Constraint to use when optimizing the embedding. Options are &#39;standardized&#39;,</span>
<span class="sd">        &#39;centered&#39;, `None` or a `pymde.constraints.Constraint()` function.</span>
<span class="sd">    n_neighbors : int (optional)</span>
<span class="sd">        The number of nearest neighbors to compute for each row (item) of</span>
<span class="sd">        ``data``. A sensible value is chosen by default, depending on the</span>
<span class="sd">        number of items.</span>
<span class="sd">    repulsive_fraction : float (optional)</span>
<span class="sd">        How many repulsive edges to include, relative to the number</span>
<span class="sd">        of attractive edges. ``1`` means as many repulsive edges as attractive</span>
<span class="sd">        edges. The higher this number, the more uniformly spread out the</span>
<span class="sd">        embedding will be. Defaults to ``0.5`` for standardized embeddings, and</span>
<span class="sd">        ``1`` otherwise. (If ``repulsive_penalty`` is ``None``, this argument</span>
<span class="sd">        is ignored.)</span>
<span class="sd">    max_distance : float (optional)</span>
<span class="sd">        If not None, neighborhoods are restricted to have a radius</span>
<span class="sd">        no greater than ``max_distance``.</span>
<span class="sd">    init : str or np.ndarray (optional, default &#39;quadratic&#39;)</span>
<span class="sd">        Initialization strategy; np.ndarray, &#39;quadratic&#39; or &#39;random&#39;.</span>
<span class="sd">    device : str (optional)</span>
<span class="sd">        Device for the embedding (eg, &#39;cpu&#39;, &#39;cuda&#39;).</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        If ``True``, print verbose output.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.tensor</span>
<span class="sd">        A ``pymde.MDE`` object, based on the original data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">init</span> <span class="o">==</span> <span class="s1">&#39;spectral&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Spectral initialization requires input data as argument. Falling back to quadratic...&#39;</span><span class="p">)</span>
            <span class="n">init</span> <span class="o">=</span> <span class="s1">&#39;quadratic&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_layout</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">constraint</span> <span class="o">==</span> <span class="s1">&#39;standardized&#39;</span><span class="p">:</span>
        <span class="n">constraint_use</span> <span class="o">=</span> <span class="n">constraints</span><span class="o">.</span><span class="n">Standardized</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">constraint</span> <span class="o">==</span> <span class="s1">&#39;centered&#39;</span><span class="p">:</span>
        <span class="n">constraint_use</span> <span class="o">=</span> <span class="n">constraints</span><span class="o">.</span><span class="n">Centered</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">constraints</span><span class="o">.</span><span class="n">Constraint</span><span class="p">()):</span>
        <span class="n">constraint_use</span> <span class="o">=</span> <span class="n">constraint</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">constraint_use</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;isomorphic&#39;</span><span class="p">:</span>
        <span class="n">emb</span> <span class="o">=</span> <span class="n">mde</span><span class="o">.</span><span class="n">IsomorphicMDE</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span>
                                <span class="n">attractive_penalty</span><span class="o">=</span><span class="n">attractive_penalty</span><span class="p">,</span>
                                <span class="n">repulsive_penalty</span><span class="o">=</span><span class="n">repulsive_penalty</span><span class="p">,</span>
                                <span class="n">embedding_dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                                <span class="n">constraint</span><span class="o">=</span><span class="n">constraint_use</span><span class="p">,</span>
                                <span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span>
                                <span class="n">repulsive_fraction</span><span class="o">=</span><span class="n">repulsive_fraction</span><span class="p">,</span>
                                <span class="n">max_distance</span><span class="o">=</span><span class="n">max_distance</span><span class="p">,</span>
                                <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
                                <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;isometric&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_distance</span> <span class="o">=</span> <span class="mf">5e7</span>
        <span class="n">emb</span> <span class="o">=</span> <span class="n">mde</span><span class="o">.</span><span class="n">IsometricMDE</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span>
                               <span class="n">embedding_dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                               <span class="n">loss</span><span class="o">=</span><span class="n">loss</span><span class="p">,</span>
                               <span class="n">constraint</span><span class="o">=</span><span class="n">constraint_use</span><span class="p">,</span>
                               <span class="n">max_distances</span><span class="o">=</span><span class="n">max_distance</span><span class="p">,</span>
                               <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                               <span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">emb</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="topo.models.TopOGraph.spectral_layout" class="doc doc-heading">
<code class="highlight language-python"><span class="n">spectral_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents ">

      <p>Performs a multicomponent spectral layout of the data and the target similarity matrix.</p>
<h5 id="topo.models.TopOGraph.spectral_layout--parameters">Parameters</h5>
<p>data :
    input data
target : scipy.sparse.csr.csr_matrix.
    target similarity matrix.
dim : int (optional, default 2)
    number of dimensions to embed into.</p>
<h5 id="topo.models.TopOGraph.spectral_layout--returns">Returns</h5>
<p>np.ndarray containing the resulting embedding.</p>

        <details class="quote">
          <summary>Source code in <code>topo/models.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">spectral_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Performs a multicomponent spectral layout of the data and the target similarity matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data :</span>
<span class="sd">        input data</span>
<span class="sd">    target : scipy.sparse.csr.csr_matrix.</span>
<span class="sd">        target similarity matrix.</span>
<span class="sd">    dim : int (optional, default 2)</span>
<span class="sd">        number of dimensions to embed into.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray containing the resulting embedding.</span>

<span class="sd">    &quot;&quot;&quot;</span>



    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;diffusion&#39;</span><span class="p">:</span>
        <span class="n">spt_layout</span> <span class="o">=</span> <span class="n">spt</span><span class="o">.</span><span class="n">spectral_layout</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">DiffBasis</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">dim</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">expansion</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spt_layout</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">spt_layout</span> <span class="o">=</span> <span class="p">(</span><span class="n">spt_layout</span> <span class="o">*</span> <span class="n">expansion</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
            <span class="n">scale</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DiffBasis</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
        <span class="n">spt_layout</span> <span class="o">=</span> <span class="n">spt</span><span class="o">.</span><span class="n">LapEigenmap</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ContBasis</span><span class="o">.</span><span class="n">K</span><span class="p">,</span>
            <span class="n">dim</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">expansion</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spt_layout</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">spt_layout</span> <span class="o">=</span> <span class="p">(</span><span class="n">spt_layout</span> <span class="o">*</span> <span class="n">expansion</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
            <span class="n">scale</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ContBasis</span><span class="o">.</span><span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">spt_layout</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="topo.models.TopOGraph.transform" class="doc doc-heading">
<code class="highlight language-python"><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></code>


</h3>

    <div class="doc doc-contents ">

      <p>Learns new affinity, topological operators from chosen basis.</p>
<h5 id="topo.models.TopOGraph.transform--parameters">Parameters</h5>
<p>self :
    TopOGraph instance.</p>
<p>base : str, optional.
    Base to use when building the topological graph. Defaults to the active base ( <code>TopOGraph.basis</code>)</p>
<h5 id="topo.models.TopOGraph.transform--returns">Returns</h5>
<p>scipy.sparse.csr.csr_matrix, containing the similarity matrix that encodes the topological graph.</p>

        <details class="quote">
          <summary>Source code in <code>topo/models.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Learns new affinity, topological operators from chosen basis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self :</span>
<span class="sd">        TopOGraph instance.</span>

<span class="sd">    base : str, optional.</span>
<span class="sd">        Base to use when building the topological graph. Defaults to the active base ( `TopOGraph.basis`)</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scipy.sparse.csr.csr_matrix, containing the similarity matrix that encodes the topological graph.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="n">base</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Building topological graph...&#39;</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
        <span class="n">use_basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CLapMap</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">==</span> <span class="s1">&#39;diffusion&#39;</span><span class="p">:</span>
        <span class="n">use_basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MSDiffMap</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">==</span> <span class="s1">&#39;diff&#39;</span><span class="p">:</span>
        <span class="n">DiffGraph</span> <span class="o">=</span> <span class="n">Diffusor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_knn</span><span class="p">,</span>
                             <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                             <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                             <span class="n">ann</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">,</span>
                             <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_metric</span><span class="p">,</span>
                             <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span>
                             <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                             <span class="n">efC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efC</span><span class="p">,</span>
                             <span class="n">efS</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efS</span><span class="p">,</span>
                             <span class="n">kernel_use</span><span class="o">=</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span>
                             <span class="n">norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span>
                             <span class="n">transitions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">,</span>
                             <span class="n">eigengap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eigengap</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                             <span class="n">plot_spectrum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_spectrum</span><span class="p">,</span>
                             <span class="n">cache</span><span class="o">=</span><span class="kc">False</span>
                             <span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">use_basis</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_graph</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">DiffGraph</span> <span class="o">=</span> <span class="n">DiffGraph</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">==</span> <span class="s1">&#39;cknn&#39;</span><span class="p">:</span>
        <span class="n">CknnGraph</span> <span class="o">=</span> <span class="n">cknn_graph</span><span class="p">(</span><span class="n">use_basis</span><span class="p">,</span>
                               <span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_knn</span><span class="p">,</span>
                               <span class="n">delta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span>
                               <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_metric</span><span class="p">,</span>
                               <span class="n">t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span>
                               <span class="n">include_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">is_sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_graph</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CknnGraph</span> <span class="o">=</span> <span class="n">CknnGraph</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Topological graph extracted in = </span><span class="si">%f</span><span class="s1"> (sec)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">==</span> <span class="s1">&#39;diff&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DiffGraph</span><span class="o">.</span><span class="n">T</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">==</span> <span class="s1">&#39;cknn&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CknnGraph</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../diffusor/" class="btn btn-neutral float-right" title="Diffusion harmonics">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../TopOMetry_Intro_pbmc_10k/" class="btn btn-neutral" title="Single-cell analysis"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../TopOMetry_Intro_pbmc_10k/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../diffusor/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
